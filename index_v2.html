<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Barricade / Malefiz ‚Äî plateau fid√®le (multijoueur)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg:#0b1220;
      --panel:#0e1730;
      --line:#2a3b66;
      --text:#e8ecf1;
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,sans-serif}
    header{display:flex;gap:12px;align-items:center;padding:12px 16px;border-bottom:1px solid var(--line);background:var(--panel)}
    header h1{font-size:18px;margin:0}
    main{display:grid;grid-template-columns:1fr 360px;gap:16px;padding:16px}
    #right{background:var(--panel);border:1px solid var(--line);border-radius:14px;padding:12px;display:flex;flex-direction:column;gap:10px}
    #controls input,#controls select,#controls button{font:inherit;border-radius:10px;border:1px solid var(--line);background:#102046;color:var(--text);padding:8px 10px}
    #controls button.primary{background:#2b6ae6;border-color:#2b6ae6;color:white;font-weight:700}
    #players{display:flex;gap:6px;flex-wrap:wrap}
    .tag{padding:4px 8px;border-radius:999px;border:1px solid var(--line);background:#0f1e42;font-size:12px}
    .dot{display:inline-block;width:10px;height:10px;border-radius:50%;margin-right:6px;vertical-align:-1px}
    #log{background:#0f1e42;border:1px solid var(--line);border-radius:10px;padding:8px;height:200px;overflow:auto;white-space:pre-wrap;font-size:12px}
    .hint{cursor:pointer;filter:drop-shadow(0 0 6px #f6c35c)}
    .clickable-edge{stroke:#f6c35c;stroke-width:6}
    .goal-ring{stroke:#fff;stroke-width:3}
  </style>
</head>
<body>
<header>
  <h1>üß± Barricade / Malefiz ‚Äî plateau fid√®le (Firebase, 4 joueurs, 5 pions chacun)</h1>
  <div id="live"></div>
</header>
<main>
  <div id="boardWrap" style="overflow:auto;background:var(--panel);border:1px solid var(--line);border-radius:14px;padding:6px;">
    <svg id="svg" viewBox="0 0 1000 1000" width="100%" height="100%"
         style="display:block;background:#0f1832;border-radius:10px">
      <!-- Edges will be drawn here -->
      <g id="edges" stroke="#445d9c" stroke-width="4" fill="none" stroke-linecap="round"></g>
      <!-- Nodes (circles) -->
      <g id="nodes"></g>
      <!-- Pawns and barricades -->
      <g id="pieces"></g>
    </svg>
  </div>

  <aside id="right">
    <section id="controls">
      <div style="display:flex;gap:6px;flex-wrap:wrap">
        <input id="gameId" placeholder="code de partie (ex: famille1)" style="flex:1;min-width:160px">
        <button id="newGame">Nouvelle partie</button>
        <button id="joinGame" class="primary">Rejoindre</button>
      </div>
      <div style="display:flex;gap:6px;flex-wrap:wrap;margin-top:6px">
        <input id="nameInput" placeholder="ton pseudo" style="flex:1">
        <select id="colorInput">
          <option value="red">rouge</option>
          <option value="blue">bleu</option>
          <option value="green">vert</option>
          <option value="yellow">jaune</option>
        </select>
      </div>
      <hr style="border-color:var(--line)">
      <div style="display:flex;gap:6px;flex-wrap:wrap">
        <button id="roll">üé≤ Lancer le d√©</button>
        <div id="dice" style="padding:8px 10px;border-radius:10px;border:1px solid var(--line)">D√© : ‚Äî</div>
      </div>
      <div>Tour : <strong id="turn">‚Äî</strong></div>
      <div>Joueurs :</div>
      <div id="players"></div>
      <div style="margin-top:6px"><a href="#" id="copyLink" style="color:#9db7ff">Copier le lien de cette partie</a></div>
    </section>

    <section>
      <div><strong>Journal</strong></div>
      <div id="log"></div>
    </section>

    <section style="font-size:12px;opacity:.85">
      <p><strong>‚öôÔ∏è Firebase :</strong> √©dite ce fichier et remplace <code>firebaseConfig</code> par celui de ton projet (Realtime Database en mode test). Puis rafra√Æchis la page.</p>
    </section>
  </aside>
</main>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-app.js";
  import { getDatabase, ref, set, onValue, update, runTransaction } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-database.js";

  // ===== ‚ö†Ô∏è Remplace par TA configuration (Firebase console ‚Üí Web app) =====
  const firebaseConfig = {
    apiKey: "REMPLACE_MOI",
    authDomain: "REMPLACE_MOI.firebaseapp.com",
    databaseURL: "https://REMPLACE_MOI-default-rtdb.firebaseio.com",
    projectId: "REMPLACE_MOI"
  };
  // =========================================================================

  const app = initializeApp(firebaseConfig);
  const db  = getDatabase(app);

  const COLORS = { red:"#e74b4b", blue:"#3a7bff", green:"#2fbf71", yellow:"#e5c14b" };

  const svg   = document.getElementById("svg");
  const G_EDGES  = document.getElementById("edges");
  const G_NODES  = document.getElementById("nodes");
  const G_PIECES = document.getElementById("pieces");
  const diceEl = document.getElementById("dice");
  const turnEl = document.getElementById("turn");
  const playersEl = document.getElementById("players");
  const logEl = document.getElementById("log");

  const newBtn  = document.getElementById("newGame");
  const joinBtn = document.getElementById("joinGame");
  const rollBtn = document.getElementById("roll");
  const gameIdInput = document.getElementById("gameId");
  const nameInput   = document.getElementById("nameInput");
  const colorInput  = document.getElementById("colorInput");
  const copyLink    = document.getElementById("copyLink");

  const urlParams = new URLSearchParams(location.search);
  if(urlParams.get("game")) gameIdInput.value = urlParams.get("game");

  copyLink.addEventListener("click",(e)=>{
    e.preventDefault();
    const id = gameIdInput.value.trim()||"partie";
    const url = location.origin + location.pathname + "?game=" + encodeURIComponent(id);
    navigator.clipboard.writeText(url);
    toast("Lien copi√© : "+url);
  });

  function toast(t){ log(t); }
  function log(t){ const time = new Date().toLocaleTimeString(); logEl.textContent = `[${time}] ${t}\n` + logEl.textContent; }

  // =============== Board topology (approx faithful to classic Malefiz) ==================
  // We'll place nodes by (x,y) and connect edges to reproduce the image layout.
  // Node ids are strings like "n1","n2"... plus special "goal" and 4 homes arrays.

  // Helper to generate linear sequences
  function line(idPrefix, startX, startY, count, stepX=30, stepY=0){
    const arr=[]; for(let i=0;i<count;i++){ arr.push({ id:`${idPrefix}${i}`, x:startX+i*stepX, y:startY+i*stepY }); } return arr;
  }

  // Top long lane
  const topLane = line("t", 140, 120, 23, 32, 0); // 23 nodes
  // Top goal connector: one node under the lane then goal
  const topStem = line("g", 480, 150, 3, 0, 45); // g0 near lane, g2 downwards towards mid

  // Middle pyramid (3 levels) approximate
  const pyr1 = line("p1_", 420, 360, 3, 80, 0);      // top of pyramid (3)
  const pyr2 = line("p2_", 380, 420, 5, 80, 0);      // mid (5)
  const pyr3 = line("p3_", 340, 480, 7, 80, 0);      // base (7)

  // Large middle horizontal
  const midLane = line("m", 140, 560, 23, 32, 0);

  // Bottom left & right loops towards starts
  const leftStem  = line("ls", 140, 560, 4, 0, 60);   // down from midLane
  const rightStem = line("rs", 140+32*22, 560, 4, 0, 60);
  const leftLoop  = line("ll", 140, 560+60*3, 6, 32, 0);
  const rightLoop = line("rl", 140+32*17, 560+60*3, 6, 32, 0);

  // Start bays (5 circles each) roughly under the midLane
  const starts = {
    green:  line("hg", 200, 760, 5, 32, 0).map(n=>({id:n.id,x:n.x,y:n.y,home:"green"})),
    red:    line("hr", 200+32*6, 760, 5, 32, 0).map(n=>({id:n.id,x:n.x,y:n.y,home:"red"})),
    yellow: line("hy", 200+32*12,760, 5, 32, 0).map(n=>({id:n.id,x:n.x,y:n.y,home:"yellow"})),
    blue:   line("hb", 200+32*18,760, 5, 32, 0).map(n=>({id:n.id,x:n.x,y:n.y,home:"blue"}))
  };

  // Join all path nodes (excluding home bays)
  const nodes = [
    ...topLane, ...topStem, ...pyr1, ...pyr2, ...pyr3,
    ...midLane, ...leftStem, ...rightStem, ...leftLoop, ...rightLoop
  ];

  const NODE = Object.fromEntries(nodes.map(n=>[n.id,n]));

  // Adjacency map for path graph
  const adj = {};
  function connect(a,b){ (adj[a]||(adj[a]=[])).push(b); (adj[b]||(adj[b]=[])).push(a); }

  // Connect top lane linear
  for(let i=0;i<topLane.length-1;i++) connect(topLane[i].id, topLane[i+1].id);
  // Connect stem to lane center
  connect("t11", "g0"); connect("g0","g1"); connect("g1","g2"); // downwards

  // Connect stem bottom to pyramid top center
  connect("g2", "p1_1");
  // Pyramid connections
  for(let i=0;i<pyr1.length-1;i++) connect(pyr1[i].id, pyr1[i+1].id);
  for(let i=0;i<pyr2.length-1;i++) connect(pyr2[i].id, pyr2[i+1].id);
  for(let i=0;i<pyr3.length-1;i++) connect(pyr3[i].id, pyr3[i+1].id);
  // verticals in pyramid
  connect("p1_0","p2_1"); connect("p1_1","p2_2"); connect("p1_2","p2_3");
  connect("p2_0","p3_1"); connect("p2_1","p3_2"); connect("p2_2","p3_3"); connect("p2_3","p3_4"); connect("p2_4","p3_5");

  // Connect pyramid base to midLane
  connect("p3_0","m7"); connect("p3_6","m15");

  // Mid lane linear
  for(let i=0;i<midLane.length-1;i++) connect(midLane[i].id, midLane[i+1].id);

  // Stems to loops
  connect("m0","ls0"); connect("ls0","ls1"); connect("ls1","ls2"); connect("ls2","ls3"); connect("ls3","ll0");
  connect("m22","rs0"); connect("rs0","rs1"); connect("rs1","rs2"); connect("rs2","rs3"); connect("rs3","rl0");

  // Left & right loops
  for(let i=0;i<leftLoop.length-1;i++) connect(leftLoop[i].id, leftLoop[i+1].id);
  for(let i=0;i<rightLoop.length-1;i++) connect(rightLoop[i].id, rightLoop[i+1].id);

  // Entry cells for colors
  const ENTRY = { green:"m5", red:"m11", yellow:"m17", blue:"m21" };

  // Draw edges & nodes
  function drawEdges(){
    G_EDGES.innerHTML="";
    for(const [a,ns] of Object.entries(adj)){
      const A = NODE[a]; if(!A) continue;
      ns.forEach(b=>{
        const B = NODE[b]; if(!B) return;
        const line = document.createElementNS("http://www.w3.org/2000/svg","line");
        line.setAttribute("x1",A.x); line.setAttribute("y1",A.y);
        line.setAttribute("x2",B.x); line.setAttribute("y2",B.y);
        G_EDGES.appendChild(line);
      });
    }
  }
  function drawNodes(){
    G_NODES.innerHTML="";
    for(const n of nodes){
      const c = document.createElementNS("http://www.w3.org/2000/svg","circle");
      c.setAttribute("cx", n.x); c.setAttribute("cy", n.y); c.setAttribute("r", 12);
      c.setAttribute("fill", "#14275a"); c.setAttribute("stroke","#6a87c9"); c.setAttribute("stroke-width","2");
      c.dataset.id = n.id;
      G_NODES.appendChild(c);
    }
    // goal
    const goal = document.createElementNS("http://www.w3.org/2000/svg","circle");
    const mid = topLane[11];
    goal.setAttribute("cx", mid.x); goal.setAttribute("cy", mid.y-50);
    goal.setAttribute("r", 14); goal.setAttribute("fill","#2c7e2f"); goal.setAttribute("stroke","#9be99e"); goal.setAttribute("stroke-width","3");
    goal.dataset.id="GOAL"; G_NODES.appendChild(goal);
    // connect goal to middle top
    NODE["GOAL"] = {id:"GOAL",x:mid.x,y:mid.y-50};
    connect("GOAL","t11");
  }

  const INIT_BARRICADES = ["t4","t18","m4","m8","m12","m16","m20","p3_0","p3_3","p3_6","p1_1"];

  function blankState(){
    return { order:[], turnIndex:0, dice:0, winner:"", barricades:INIT_BARRICADES.slice(), players:{} };
  }

  let ME="", MYCOLOR="red", gameRef=null;

  function allPawnsArray(players){
    const arr=[]; for(const [name,pl] of Object.entries(players||{})){ pl.pawns.forEach((p,i)=>arr.push({owner:name,color:pl.color,index:i,pos:p.pos,atHome:p.atHome})); } return arr;
  }
  function occupiedSet(players){ const s=new Set(); for(const pl of Object.values(players||{})){ pl.pawns.forEach(p=>{ if(!p.atHome) s.add(p.pos); }); } return s; }

  function drawState(state){
    G_PIECES.innerHTML="";
    // barricades
    for(const b of state.barricades){
      const n = NODE[b]; if(!n) continue;
      const rect = document.createElementNS("http://www.w3.org/2000/svg","rect");
      rect.setAttribute("x", n.x-10); rect.setAttribute("y", n.y-10);
      rect.setAttribute("width", 20); rect.setAttribute("height", 20); rect.setAttribute("rx", 5);
      rect.setAttribute("fill", "#6c5a47"); rect.setAttribute("stroke","#d7c3a4"); rect.setAttribute("stroke-width","2");
      G_PIECES.appendChild(rect);
    }
    // pawns
    for(const [name,pl] of Object.entries(state.players||{})){
      for(let i=0;i<pl.pawns.length;i++){
        const p=pl.pawns[i]; let x,y;
        if(p.atHome){
          const S={green:starts.green[i], red:starts.red[i], yellow:starts.yellow[i], blue:starts.blue[i]}[pl.color];
          x=S.x; y=S.y;
        }else{ const n=NODE[p.pos]; if(!n) continue; x=n.x; y=n.y; }
        const g = document.createElementNS("http://www.w3.org/2000/svg","g");
        const c = document.createElementNS("http://www.w3.org/2000/svg","circle");
        c.setAttribute("cx",x); c.setAttribute("cy",y); c.setAttribute("r","11");
        c.setAttribute("fill",COLORS[pl.color]||"#888"); c.setAttribute("stroke","#fff"); c.setAttribute("stroke-width","2");
        const txt = document.createElementNS("http://www.w3.org/2000/svg","text");
        txt.setAttribute("x",x); txt.setAttribute("y",y+4); txt.setAttribute("text-anchor","middle"); txt.setAttribute("font-size","10"); txt.setAttribute("fill","#fff"); txt.textContent=(i+1);
        g.appendChild(c); g.appendChild(txt); G_PIECES.appendChild(g);
      }
    }
    // side UI
    playersEl.innerHTML="";
    Object.entries(state.players||{}).forEach(([name,pl])=>{
      const tag=document.createElement("div"); tag.className="tag"; tag.innerHTML=`<span class="dot" style="background:${COLORS[pl.color]}"></span>${name}`; playersEl.appendChild(tag);
    });
    diceEl.textContent="D√© : "+(state.dice||"‚Äî"); const cur=state.order[state.turnIndex]||"‚Äî"; turnEl.textContent=cur+(cur===ME?" (√† toi)":"");
  }

  function reachable(start, steps, blockedSet){
    let cur=new Set([start]); for(let s=0;s<steps;s++){ const nxt=new Set(); for(const k of cur){ for(const n of (adj[k]||[])){ if(blockedSet.has(n)) continue; nxt.add(n); } } cur=nxt; } return cur;
  }

  newBtn.addEventListener("click", async ()=>{
    const id = prompt("Code de partie (ex: famille1)") || "demo"; gameIdInput.value=id;
    await set(ref(db,"games/"+id), blankState());
    toast("Partie cr√©√©e. Clique ¬´ Rejoindre ¬ª ensuite et partage le lien.");
  });

  joinBtn.addEventListener("click", async ()=>{
    const id=gameIdInput.value.trim(); if(!id) return alert("Entre un code de partie.");
    const name=(nameInput.value||"").trim(); if(!name) return alert("Entre un pseudo.");
    const color=colorInput.value; ME=name; MYCOLOR=color;
    gameRef = ref(db,"games/"+id);
    await runTransaction(gameRef,(st)=>{
      if(st==null) st=blankState();
      if(!st.players[name]){
        if(Object.keys(st.players).length>=4){ alert("Partie pleine (4 joueurs)."); return; }
        st.players[name]={ color, pawns:Array.from({length:5}).map(()=>({pos:"home",atHome:true})), won:false };
        st.order.push(name);
      }
      return st;
    });
    onValue(gameRef,(snap)=>{ const st=snap.val(); if(!st) return; drawState(st); enableTurn(st); });
  });

  rollBtn.addEventListener("click", async ()=>{
    if(!gameRef) return alert("Rejoins d'abord une partie.");
    await runTransaction(gameRef,(st)=>{ if(!st) return st; if(st.order[st.turnIndex]!==ME) return st; st.dice=Math.floor(Math.random()*6)+1; return st; });
  });

  function enableTurn(st){
    if((st.order[st.turnIndex]||"")!==ME || !st.dice) return;
    const me = st.players[ME]; if(!me) return;
    const occ = occupiedSet(st.players);
    const blocked = new Set([...st.barricades, ...occ]);

    me.pawns.forEach((p,idx)=>{
      const start = p.atHome ? ENTRY[me.color] : p.pos;
      if(p.atHome && blocked.has(start)) return;
      if(!p.atHome) blocked.delete(start);
      const dests = Array.from(reachable(start, st.dice, blocked));
      // allow GOAL if reachable from t11 with exact step 1 via g0 (simplifi√©)
      if(start==="t11" && st.dice===1) dests.push("GOAL");
      const legal = dests.filter(k=>k==="GOAL" || NODE[k]);

      // clickable origin hint
      let x,y;
      if(p.atHome){
        const S={green:starts.green[idx], red:starts.red[idx], yellow:starts.yellow[idx], blue:starts.blue[idx]}[me.color];
        x=S.x; y=S.y;
      }else{ const n=NODE[p.pos]; if(!n) return; x=n.x; y=n.y; }
      const origin = document.createElementNS("http://www.w3.org/2000/svg","circle");
      origin.setAttribute("cx",x); origin.setAttribute("cy",y); origin.setAttribute("r","14");
      origin.setAttribute("fill","transparent"); origin.setAttribute("stroke","#f6c35c"); origin.setAttribute("stroke-width","3");
      origin.classList.add("hint");
      origin.addEventListener("click",()=>{
        clearHints();
        showTargets(legal,(dest)=>movePawn(idx,dest));
      });
      G_PIECES.appendChild(origin);
    });
  }

  function clearHints(){ [...svg.querySelectorAll(".hint")].forEach(n=>n.remove()); }
  function showTargets(keys,onPick){
    keys.forEach(k=>{
      const n = NODE[k] || NODE["GOAL"];
      const c=document.createElementNS("http://www.w3.org/2000/svg","circle");
      c.setAttribute("cx",n.x); c.setAttribute("cy",n.y); c.setAttribute("r","14");
      c.setAttribute("fill","transparent"); c.setAttribute("stroke","#f6c35c"); c.setAttribute("stroke-width","3");
      c.classList.add("hint");
      c.addEventListener("click",()=>onPick(k),{once:true});
      G_PIECES.appendChild(c);
    });
  }

  function movePawn(idx, dest){
    runTransaction(gameRef,(st)=>{
      if(!st) return st;
      if(st.order[st.turnIndex]!==ME) return st;
      const me=st.players[ME]; if(!me) return st;
      const p=me.pawns[idx];
      const start = p.atHome ? ENTRY[me.color] : p.pos;

      const occ = occupiedSet(st.players);
      const blocked = new Set([...st.barricades, ...occ]);
      if(p.atHome && blocked.has(start)) return st;
      if(!p.atHome) blocked.delete(start);
      const dests = Array.from(reachable(start, st.dice, blocked));
      if(start==="t11" && st.dice===1) dests.push("GOAL");
      if(!dests.includes(dest)) return st;

      // capture
      for(const [opName,op] of Object.entries(st.players)){
        if(opName===ME) continue;
        op.pawns.forEach(opP=>{
          if(!opP.atHome && opP.pos===dest){ opP.atHome=true; opP.pos="home"; }
        });
      }

      p.atHome=false; p.pos=dest;

      if(dest==="GOAL"){ st.winner=ME; }

      const bIndex = st.barricades.indexOf(dest);
      if(bIndex>=0){
        st.barricades.splice(bIndex,1);
        st._mustPlaceBarricade=true; st._placer=ME;
      }else{
        st.dice=0; if(!st.winner) st.turnIndex=(st.turnIndex+1)%st.order.length;
      }
      return st;
    });
    clearHints();
  }

  function enableBarricadePlacement(st){
    if(!st._mustPlaceBarricade || st._placer!==ME) return;
    const occ = occupiedSet(st.players);
    const choices = Object.keys(NODE).filter(id=>NODE[id] && id!=="GOAL" && !occ.has(id));
    showTargets(choices,(dest)=>{
      runTransaction(gameRef,(S)=>{
        if(!S || !S._mustPlaceBarricade || S._placer!==ME) return S;
        if(!NODE[dest] || dest==="GOAL") return S;
        if(occupiedSet(S.players).has(dest)) return S;
        S.barricades.push(dest);
        S._mustPlaceBarricade=false; S._placer="";
        S.dice=0; if(!S.winner) S.turnIndex=(S.turnIndex+1)%S.order.length;
        return S;
      });
      clearHints();
    });
    toast("Place la barricade r√©cup√©r√©e : clique sur un n≈ìud (pas sur l'arriv√©e).");
  }

  function subscribe(gref){
    onValue(gref,(snap)=>{
      const st=snap.val(); if(!st) return;
      drawState(st);
      if(st._mustPlaceBarricade && st._placer===ME) enableBarricadePlacement(st);
    });
  }

  drawEdges(); drawNodes();

  joinBtn.addEventListener("click",()=>{
    const id = gameIdInput.value.trim();
    if(id) subscribe(ref(db,"games/"+id));
  });
</script>
</body>
</html>
