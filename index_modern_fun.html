<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Malefiz ‚Äî v9 (barricades instant + correctifs handlers)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
  :root{
    --bg:#050712;              /* fond global tr√®s sombre, neutre */
    --bg-soft:#0b1020;
    --panel:#080b18;           /* cartes / panneaux */
    --panel-soft:#101626;
    --accent:#fb923c;          /* orange corail chaleureux */
    --accent-soft:rgba(251,146,60,.18);
    --accent-strong:#f97316;
    --accent-alt:#22c55e;      /* accent secondaire (validation) */
    --text:#e5e7eb;
    --text-soft:#9ca3af;
    --border-soft:rgba(148,163,184,.45);
    --danger:#f97373;
  }

  *{box-sizing:border-box}

  body{
    margin:0;
    min-height:100vh;
    background:
      radial-gradient(circle at 0% 0%,#1f2937 0,#020617 40%),
      radial-gradient(circle at 100% 100%,#111827 0,#020617 55%);
    color:var(--text);
    font-family:system-ui,-apple-system,"Segoe UI",Roboto,sans-serif;
  }

  /* =========================
     CARTES / LAYOUT G√âN√âRAL
     ========================= */

  .card{
    background:
      radial-gradient(circle at 0 0,rgba(251,146,60,.16) 0,transparent 55%),
      linear-gradient(145deg,#020617,#020617,#020617,#020617,#020617,#020617,#020617,#020617,#020617,#020617);
    border:1px solid var(--border-soft);
    border-radius:20px;
    padding:18px 16px;
    margin:14px;
    box-shadow:
      0 24px 55px rgba(0,0,0,.85),
      0 0 0 1px rgba(15,23,42,.85);
  }

  .row{
    display:flex;
    gap:10px;
    flex-wrap:wrap;
    align-items:flex-start;
  }

  .col{
    display:flex;
    flex-direction:column;
    gap:8px;
  }

  h3{
    margin:0 0 12px;
    font-size:20px;
    letter-spacing:.08em;
    text-transform:uppercase;
    color:#f9fafb;
    display:flex;
    align-items:center;
    gap:8px;
  }

  h3::before{
    content:"üé≤";
    font-size:18px;
  }

  label{
    font-size:12px;
    text-transform:uppercase;
    letter-spacing:.08em;
    color:var(--text-soft);
  }

  /* =========================
     FORMULAIRES & CHAMPS
     ========================= */

  input,
  select,
  button{
    font:inherit;
    border-radius:999px;
    border:1px solid var(--border-soft);
    background:rgba(15,23,42,.95);
    padding:9px 13px;
    color:var(--text);
    outline:none;
    transition:
      border-color .16s ease,
      box-shadow .16s ease,
      background-color .14s ease,
      transform .08s ease,
      opacity .12s ease;
  }

  input::placeholder{
    color:rgba(148,163,184,.7);
  }

  input:focus,
  select:focus{
    border-color:var(--accent);
    box-shadow:0 0 0 1px rgba(251,146,60,.55);
    background:#020617;
  }

  select{
    padding-right:26px;
    background-image:linear-gradient(45deg,transparent 50%,#9ca3af 50%),
                     linear-gradient(135deg,#9ca3af 50%,transparent 50%);
    background-position:calc(100% - 12px) 12px, calc(100% - 8px) 12px;
    background-size:6px 6px,6px 6px;
    background-repeat:no-repeat;
    appearance:none;
  }

  /* =========================
     BOUTONS (MENU & IN-GAME)
     ========================= */

  button{
    display:inline-flex;
    align-items:center;
    justify-content:center;
    gap:6px;
    background:radial-gradient(circle at 0 0,rgba(251,146,60,.24) 0,transparent 60%),
               linear-gradient(135deg,#111827,#020617);
    border-color:var(--border-soft);
    color:#e5e7eb;
    font-weight:600;
    cursor:pointer;
    padding-inline:18px;
    text-shadow:0 1px 1px rgba(15,23,42,.8);
    box-shadow:
      0 3px 0 rgba(15,23,42,1),
      0 10px 20px rgba(15,23,42,.85);
  }

  button.primary{
    background:
      radial-gradient(circle at 0 0,rgba(251,146,60,.35) 0,transparent 55%),
      linear-gradient(135deg,var(--accent-strong),#b45309);
    border-color:transparent;
    color:#020617;
    box-shadow:
      0 3px 0 rgba(120,53,15,1),
      0 14px 30px rgba(251,146,60,.65);
  }

  #menu .row[style*="margin-top"] button{
    min-width:170px;
    justify-content:center;
  }

  button:disabled{
    opacity:.45;
    cursor:not-allowed;
    box-shadow:none;
    transform:none;
  }

  button:not(:disabled):hover{
    transform:translateY(-1px);
    box-shadow:
      0 5px 0 rgba(15,23,42,1),
      0 16px 30px rgba(0,0,0,.85);
  }

  button:not(:disabled):active{
    transform:translateY(1px);
    box-shadow:
      0 1px 0 rgba(15,23,42,1),
      0 8px 16px rgba(0,0,0,.9) inset;
  }

  button.primary:not(:disabled):hover{
    box-shadow:
      0 5px 0 rgba(120,53,15,1),
      0 18px 36px rgba(251,146,60,.75);
  }

  /* =========================
     ZONE LOBBY & BADGES JOUEURS
     ========================= */

  #lobby{
    margin-top:10px;
    padding:10px 10px 6px;
    border-radius:14px;
    background:linear-gradient(135deg,rgba(15,23,42,.9),rgba(15,23,42,.7));
    border:1px dashed rgba(148,163,184,.6);
  }

  #lobbyList .tag,
  #players .tag{
    padding:5px 10px;
    border-radius:999px;
    background:rgba(15,23,42,.9);
    border:1px solid rgba(148,163,184,.7);
    font-size:12px;
    display:inline-flex;
    align-items:center;
    gap:6px;
    color:var(--text-soft);
  }

  .tag .dot{
    display:inline-block;
    width:9px;
    height:9px;
    border-radius:999px;
    box-shadow:0 0 0 1px #020617,0 0 6px rgba(15,23,42,.9);
  }

  .notice{
    font-size:12px;
    color:var(--text-soft);
    opacity:.9;
  }

  /* =========================
     PLATEAU / SVG
     ========================= */

  #wrap{
    overflow:hidden;
    border-radius:18px;
    border:1px solid rgba(148,163,184,.6);
    background:
      radial-gradient(circle at 10% 0%,rgba(251,146,60,.32) 0,transparent 55%),
      radial-gradient(circle at 100% 100%,rgba(34,197,94,.2) 0,transparent 45%),
      radial-gradient(circle at 0 100%,rgba(129,140,248,.18) 0,transparent 40%),
      #020617;
    position:relative;
    box-shadow:
      0 20px 50px rgba(15,23,42,.95),
      0 0 0 1px rgba(15,23,42,.9);
  }

  #svg{
    touch-action:none;
    display:block;
    width:100%;
    height:70vh;
  }

  /* chemins */
  .edge{
    stroke:rgba(148,163,184,.9);
    stroke-width:4;
    stroke-linecap:round;
    opacity:.95;
    filter:drop-shadow(0 1px 3px rgba(15,23,42,.9));
  }

  /* ronds du plateau */
  .node{
    fill:#020617;
    stroke:rgba(209,213,219,.9);
    stroke-width:2.4;
    filter:
      drop-shadow(0 0 10px rgba(15,23,42,1))
      drop-shadow(0 0 4px rgba(148,163,184,.9));
  }

  /* Barricades */
  .barricade{
    fill:#020617;
    stroke:var(--accent-strong);
    stroke-width:2.4;
    filter:
      drop-shadow(0 0 10px rgba(248,113,113,.7))
      drop-shadow(0 2px 4px rgba(0,0,0,1));
  }

  /* Pions : couleurs JS conserv√©es, on ne touche qu'√† la "pr√©sentation" */
  .pawn{
    stroke:#020617;
    stroke-width:3;
    filter:
      drop-shadow(0 2px 4px rgba(0,0,0,.9))
      drop-shadow(0 0 4px rgba(15,23,42,.9));
  }

  /* Surbrillance coups possibles */
  .hint-origin,
  .hint-target{
    fill:transparent;
    cursor:pointer;
    pointer-events:all;
  }

  .hint-origin{
    stroke:#38bdf8;
    stroke-width:3;
    stroke-dasharray:4 4;
    filter:
      drop-shadow(0 0 6px rgba(56,189,248,.95))
      drop-shadow(0 0 2px rgba(15,23,42,1));
  }

  .hint-target{
    stroke:#facc15;
    stroke-width:3;
    filter:
      drop-shadow(0 0 8px rgba(250,204,21,1))
      drop-shadow(0 0 2px rgba(15,23,42,1));
  }

  .select{
    fill:transparent;
    stroke:#a855f7;
    stroke-width:4;
    pointer-events:none;
    filter:
      drop-shadow(0 0 12px rgba(168,85,247,1))
      drop-shadow(0 0 4px rgba(15,23,42,1));
  }

  /* =========================
     JOURNAL
     ========================= */

  #log{
    height:160px;
    overflow:auto;
    background:radial-gradient(circle at 0 0,rgba(30,64,175,.35) 0,transparent 55%),
               radial-gradient(circle at 100% 100%,rgba(249,115,22,.25) 0,transparent 50%),
               rgba(15,23,42,.95);
    border:1px solid rgba(148,163,184,.7);
    border-radius:14px;
    padding:10px;
    white-space:pre-wrap;
    font-size:12px;
    font-family:ui-monospace,Menlo,Monaco,"SF Mono",monospace;
    color:var(--text-soft);
  }

  #log::-webkit-scrollbar{
    width:6px;
  }
  #log::-webkit-scrollbar-track{
    background:transparent;
  }
  #log::-webkit-scrollbar-thumb{
    background:rgba(148,163,184,.8);
    border-radius:999px;
  }

  /* =========================
     ZONE D√â & INFO TOUR
     ========================= */

  #game .row[style*="justify-content:space-between"]{
    row-gap:8px;
  }

  #roll{
    font-size:14px;
    padding-inline:20px;
  }

  #dice{
    min-width:130px;
    padding:7px 14px;
    border-radius:999px;
    border:1px solid rgba(148,163,184,.8);
    background:
      radial-gradient(circle at 0 0,rgba(251,146,60,.28) 0,transparent 55%),
      linear-gradient(135deg,#020617,#020617,#020617);
    font-weight:700;
    text-align:center;
    box-shadow:
      0 3px 0 rgba(15,23,42,1),
      0 10px 18px rgba(15,23,42,.9);
    color:#f9fafb;
  }

  #turn{
    color:var(--accent);
    font-weight:700;
  }
</style>
</head>
<body>
<section id="menu" class="card">
  <h3>Malefiz ‚Äî cr√©er/rejoindre</h3>
  <div class="row">
    <div class="col" style="min-width:180px;flex:1">
      <label>Pseudo</label><input id="m_name" placeholder="ex: Camille">
    </div>
    <div class="col" style="width:150px">
      <label>Couleur</label>
      <select id="m_color"><option value="red">Rouge</option><option value="blue">Bleu</option><option value="green">Vert</option><option value="yellow">Jaune</option></select>
    </div>
    <div class="col" style="min-width:180px;flex:1">
      <label>Code de partie</label><input id="m_game" placeholder="ex: famille1">
    </div>
  </div>
  <div class="row" style="margin-top:6px">
    <button id="m_create" class="primary">Cr√©er la partie</button>
    <button id="m_join">Rejoindre la partie</button>
  </div>
  <div id="lobby" style="display:none;margin-top:10px">
    <div><strong>Joueurs connect√©s</strong></div>
    <div id="lobbyList" class="row" style="gap:6px"></div>
    <div class="row" style="margin-top:10px;align-items:center;gap:10px">
      <button id="m_start" class="primary">D√©marrer la partie</button>
      <span class="notice">Seul l'h√¥te peut d√©marrer. Minimum 2 joueurs.</span>
    </div>
  </div>
</section>

<section id="game" class="card" style="display:none">
  <div class="row" style="align-items:center;justify-content:space-between">
    <div class="row" style="gap:12px;align-items:center">
      <button id="roll">üé≤ Lancer le d√©</button>
      <div id="dice">D√© : ‚Äî</div>
      <div>Tour : <strong id="turn">‚Äî</strong></div>
      <div id="phase" class="notice"></div>
    </div>
    <div id="players" class="row" style="gap:6px"></div>
  </div>
  <div id="wrap" style="margin-top:10px">
    <svg id="svg" viewBox="0 0 1090 1300" xmlns="http://www.w3.org/2000/svg">
      <g id="edges"></g>
      <g id="nodes"></g>
      <g id="homes"></g>
      <g id="pieces"></g>
      <g id="ui"></g>
    </svg>
  </div>
  <div class="col" style="margin-top:10px">
    <div><strong>Journal</strong></div><div id="log"></div>
  </div>
</section>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-app.js";
import { getDatabase, ref, set, onValue, runTransaction } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-database.js";

// ‚ö†Ô∏è COLLE ICI TA CONFIG
const firebaseConfig = {

  apiKey: "AIzaSyDqZOF5bsuzH7dH3TvQiY9JknZWXYJsEE4",

  authDomain: "barricade-en-ligne.firebaseapp.com",

  databaseURL: "https://barricade-en-ligne-default-rtdb.europe-west1.firebasedatabase.app",

  projectId: "barricade-en-ligne",

  storageBucket: "barricade-en-ligne.firebasestorage.app",

  messagingSenderId: "1094029683667",

  appId: "1:1094029683667:web:e3d6b9ad3b44b337d29d26"

};


const app = initializeApp(firebaseConfig);
const db = getDatabase(app);

const COLORS={red:"#e74b4b",blue:"#3a7bff",green:"#2fbf71",yellow:"#e5c14b"};
const NODES = [{"id": "n1", "x": 120, "y": 900, "n": 1}, {"id": "n2", "x": 170, "y": 900, "n": 2}, {"id": "n3", "x": 220, "y": 900, "n": 3}, {"id": "n4", "x": 270, "y": 900, "n": 4}, {"id": "n5", "x": 320, "y": 900, "n": 5}, {"id": "n6", "x": 370, "y": 900, "n": 6}, {"id": "n7", "x": 420, "y": 900, "n": 7}, {"id": "n8", "x": 470, "y": 900, "n": 8}, {"id": "n9", "x": 520, "y": 900, "n": 9}, {"id": "n10", "x": 570, "y": 900, "n": 10}, {"id": "n11", "x": 620, "y": 900, "n": 11}, {"id": "n12", "x": 670, "y": 900, "n": 12}, {"id": "n13", "x": 720, "y": 900, "n": 13}, {"id": "n14", "x": 770, "y": 900, "n": 14}, {"id": "n15", "x": 820, "y": 900, "n": 15}, {"id": "n16", "x": 870, "y": 900, "n": 16}, {"id": "n17", "x": 920, "y": 900, "n": 17}, {"id": "n18", "x": 120, "y": 840, "n": 18}, {"id": "n19", "x": 320, "y": 840, "n": 19}, {"id": "n20", "x": 520, "y": 840, "n": 20}, {"id": "n21", "x": 720, "y": 840, "n": 21}, {"id": "n22", "x": 920, "y": 840, "n": 22}, {"id": "n23", "x": 120, "y": 780, "n": 23}, {"id": "n24", "x": 170, "y": 780, "n": 24}, {"id": "n25", "x": 220, "y": 780, "n": 25}, {"id": "n26", "x": 270, "y": 780, "n": 26}, {"id": "n27", "x": 320, "y": 780, "n": 27}, {"id": "n28", "x": 370, "y": 780, "n": 28}, {"id": "n29", "x": 420, "y": 780, "n": 29}, {"id": "n30", "x": 470, "y": 780, "n": 30}, {"id": "n31", "x": 520, "y": 780, "n": 31}, {"id": "n32", "x": 570, "y": 780, "n": 32}, {"id": "n33", "x": 620, "y": 780, "n": 33}, {"id": "n34", "x": 670, "y": 780, "n": 34}, {"id": "n35", "x": 720, "y": 780, "n": 35}, {"id": "n36", "x": 770, "y": 780, "n": 36}, {"id": "n37", "x": 820, "y": 780, "n": 37}, {"id": "n38", "x": 870, "y": 780, "n": 38}, {"id": "n39", "x": 920, "y": 780, "n": 39}, {"id": "n40", "x": 220, "y": 720, "n": 40}, {"id": "n41", "x": 420, "y": 720, "n": 41}, {"id": "n42", "x": 620, "y": 720, "n": 42}, {"id": "n43", "x": 820, "y": 720, "n": 43}, {"id": "n44", "x": 220, "y": 660, "n": 44}, {"id": "n45", "x": 270, "y": 660, "n": 45}, {"id": "n46", "x": 320, "y": 660, "n": 46}, {"id": "n47", "x": 370, "y": 660, "n": 47}, {"id": "n48", "x": 420, "y": 660, "n": 48}, {"id": "n49", "x": 470, "y": 660, "n": 49}, {"id": "n50", "x": 520, "y": 660, "n": 50}, {"id": "n51", "x": 570, "y": 660, "n": 51}, {"id": "n52", "x": 620, "y": 660, "n": 52}, {"id": "n53", "x": 670, "y": 660, "n": 53}, {"id": "n54", "x": 720, "y": 660, "n": 54}, {"id": "n55", "x": 770, "y": 660, "n": 55}, {"id": "n56", "x": 820, "y": 660, "n": 56}, {"id": "n57", "x": 320, "y": 600, "n": 57}, {"id": "n58", "x": 720, "y": 600, "n": 58}, {"id": "n59", "x": 320, "y": 540, "n": 59}, {"id": "n60", "x": 370, "y": 540, "n": 60}, {"id": "n61", "x": 420, "y": 540, "n": 61}, {"id": "n62", "x": 470, "y": 540, "n": 62}, {"id": "n63", "x": 520, "y": 540, "n": 63}, {"id": "n64", "x": 570, "y": 540, "n": 64}, {"id": "n65", "x": 620, "y": 540, "n": 65}, {"id": "n66", "x": 670, "y": 540, "n": 66}, {"id": "n67", "x": 720, "y": 540, "n": 67}, {"id": "n68", "x": 420, "y": 480, "n": 68}, {"id": "n69", "x": 620, "y": 480, "n": 69}, {"id": "n70", "x": 420, "y": 420, "n": 70}, {"id": "n71", "x": 470, "y": 420, "n": 71}, {"id": "n72", "x": 520, "y": 420, "n": 72}, {"id": "n73", "x": 570, "y": 420, "n": 73}, {"id": "n74", "x": 620, "y": 420, "n": 74}, {"id": "n75", "x": 520, "y": 360, "n": 75}, {"id": "n76", "x": 120, "y": 300, "n": 76}, {"id": "n77", "x": 170, "y": 300, "n": 77}, {"id": "n78", "x": 220, "y": 300, "n": 78}, {"id": "n79", "x": 270, "y": 300, "n": 79}, {"id": "n80", "x": 320, "y": 300, "n": 80}, {"id": "n81", "x": 370, "y": 300, "n": 81}, {"id": "n82", "x": 420, "y": 300, "n": 82}, {"id": "n83", "x": 470, "y": 300, "n": 83}, {"id": "n84", "x": 520, "y": 300, "n": 84}, {"id": "n85", "x": 570, "y": 300, "n": 85}, {"id": "n86", "x": 620, "y": 300, "n": 86}, {"id": "n87", "x": 670, "y": 300, "n": 87}, {"id": "n88", "x": 720, "y": 300, "n": 88}, {"id": "n89", "x": 770, "y": 300, "n": 89}, {"id": "n90", "x": 820, "y": 300, "n": 90}, {"id": "n91", "x": 870, "y": 300, "n": 91}, {"id": "n92", "x": 920, "y": 300, "n": 92}, {"id": "n93", "x": 120, "y": 240, "n": 93}, {"id": "n94", "x": 920, "y": 240, "n": 94}, {"id": "n95", "x": 120, "y": 180, "n": 95}, {"id": "n96", "x": 170, "y": 180, "n": 96}, {"id": "n97", "x": 220, "y": 180, "n": 97}, {"id": "n98", "x": 270, "y": 180, "n": 98}, {"id": "n99", "x": 320, "y": 180, "n": 99}, {"id": "n100", "x": 370, "y": 180, "n": 100}, {"id": "n101", "x": 420, "y": 180, "n": 101}, {"id": "n102", "x": 470, "y": 180, "n": 102}, {"id": "n103", "x": 520, "y": 180, "n": 103}, {"id": "n104", "x": 570, "y": 180, "n": 104}, {"id": "n105", "x": 620, "y": 180, "n": 105}, {"id": "n106", "x": 670, "y": 180, "n": 106}, {"id": "n107", "x": 720, "y": 180, "n": 107}, {"id": "n108", "x": 770, "y": 180, "n": 108}, {"id": "n109", "x": 820, "y": 180, "n": 109}, {"id": "n110", "x": 870, "y": 180, "n": 110}, {"id": "n111", "x": 920, "y": 180, "n": 111}, {"id": "n112", "x": 520, "y": 120, "n": 112}];

/** Helper: lookup node by id (no NODE_BY_ID global needed) */
function getNodeById(id){
  for (let i=0;i<NODES.length;i++){ const n = NODES[i]; if(n.id===id) return n; }
  return null;
}

const ADJ = {"n112": ["n103"], "n95": ["n96", "n93"], "n96": ["n97", "n95"], "n97": ["n98", "n96"], "n98": ["n99", "n97"], "n99": ["n100", "n98"], "n100": ["n101", "n99"], "n101": ["n102", "n100"], "n102": ["n103", "n101"], "n103": ["n104", "n102", "n112"], "n104": ["n105", "n103"], "n105": ["n106", "n104"], "n106": ["n107", "n105"], "n107": ["n108", "n106"], "n108": ["n109", "n107"], "n109": ["n110", "n108"], "n110": ["n111", "n109"], "n111": ["n110", "n94"], "n93": ["n76", "n95"], "n94": ["n92", "n111"], "n76": ["n77", "n93"], "n77": ["n78", "n76"], "n78": ["n79", "n77"], "n79": ["n80", "n78"], "n80": ["n81", "n79"], "n81": ["n82", "n80"], "n82": ["n83", "n81"], "n83": ["n84", "n82"], "n84": ["n85", "n83", "n75"], "n85": ["n86", "n84"], "n86": ["n87", "n85"], "n87": ["n88", "n86"], "n88": ["n89", "n87"], "n89": ["n90", "n88"], "n90": ["n91", "n89"], "n91": ["n92", "n90"], "n92": ["n91", "n94"], "n75": ["n72", "n84"], "n70": ["n71", "n68"], "n71": ["n72", "n70"], "n72": ["n73", "n71", "n75"], "n73": ["n74", "n72"], "n74": ["n73", "n69"], "n68": ["n61", "n70"], "n69": ["n65", "n74"], "n59": ["n60", "n57"], "n60": ["n61", "n59"], "n61": ["n62", "n60", "n68"], "n62": ["n63", "n61"], "n63": ["n64", "n62"], "n64": ["n65", "n63"], "n65": ["n66", "n64", "n69"], "n66": ["n67", "n65"], "n67": ["n66", "n58"], "n57": ["n46", "n59"], "n58": ["n54", "n67"], "n44": ["n45", "n40"], "n45": ["n46", "n44"], "n46": ["n47", "n45", "n57"], "n47": ["n48", "n46"], "n48": ["n49", "n47", "n41"], "n49": ["n50", "n48"], "n50": ["n51", "n49"], "n51": ["n52", "n50"], "n52": ["n53", "n51", "n42"], "n53": ["n54", "n52"], "n54": ["n55", "n53", "n58"], "n55": ["n56", "n54"], "n56": ["n55", "n43"], "n40": ["n25", "n44"], "n41": ["n29", "n48"], "n42": ["n33", "n52"], "n43": ["n37", "n56"], "n23": ["n24", "n18"], "n24": ["n25", "n23"], "n25": ["n26", "n24", "n40"], "n26": ["n27", "n25"], "n27": ["n28", "n26", "n19"], "n28": ["n29", "n27"], "n29": ["n30", "n28", "n41"], "n30": ["n31", "n29"], "n31": ["n32", "n30", "n20"], "n32": ["n33", "n31"], "n33": ["n34", "n32", "n42"], "n34": ["n35", "n33"], "n35": ["n36", "n34", "n21"], "n36": ["n37", "n35"], "n37": ["n38", "n36", "n43"], "n38": ["n39", "n37"], "n39": ["n38", "n22"], "n18": ["n1", "n23"], "n19": ["n5", "n27"], "n20": ["n9", "n31"], "n21": ["n13", "n35"], "n22": ["n17", "n39"], "n1": ["n2", "n18"], "n2": ["n3", "n1"], "n3": ["n4", "n2"], "n4": ["n5", "n3"], "n5": ["n6", "n4", "n19"], "n6": ["n7", "n5"], "n7": ["n8", "n6"], "n8": ["n9", "n7"], "n9": ["n10", "n8", "n20"], "n10": ["n11", "n9"], "n11": ["n12", "n10"], "n12": ["n13", "n11"], "n13": ["n14", "n12", "n21"], "n14": ["n15", "n13"], "n15": ["n16", "n14"], "n16": ["n17", "n15"], "n17": ["n16", "n22"]};
const HOMES = {"red": [{"x": 120, "y": 1050}, {"x": 170, "y": 1050}, {"x": 220, "y": 1050}, {"x": 270, "y": 1050}, {"x": 320, "y": 1050}], "green": [{"x": 320, "y": 1050}, {"x": 370, "y": 1050}, {"x": 420, "y": 1050}, {"x": 470, "y": 1050}, {"x": 520, "y": 1050}], "yellow": [{"x": 520, "y": 1050}, {"x": 570, "y": 1050}, {"x": 620, "y": 1050}, {"x": 670, "y": 1050}, {"x": 720, "y": 1050}], "blue": [{"x": 720, "y": 1050}, {"x": 770, "y": 1050}, {"x": 820, "y": 1050}, {"x": 870, "y": 1050}, {"x": 920, "y": 1050}]};
const ENTRY = {"red": "n3", "green": "n7", "yellow": "n11", "blue": "n15"};
const BARRS = ["n23", "n27", "n31", "n35", "n39", "n61", "n65", "n72", "n75", "n84", "n103"];

const NODE_BY_ID = Object.fromEntries(NODES.map(n=>[n.id,n]));
const ADJ_SAFE = new Proxy(ADJ, { get: (t, k)=> t[k] || [] });

const menu=document.getElementById('menu'), game=document.getElementById('game');
const mName=document.getElementById('m_name'), mColor=document.getElementById('m_color'), mGame=document.getElementById('m_game');
const mCreate=document.getElementById('m_create'), mJoin=document.getElementById('m_join'), mStart=document.getElementById('m_start');
const lobby=document.getElementById('lobby'), lobbyList=document.getElementById('lobbyList');
const svg=document.getElementById('svg'); const G_E=document.getElementById('edges'); const G_N=document.getElementById('nodes'); const G_H=document.getElementById('homes'); const G_P=document.getElementById('pieces'); const G_UI=document.getElementById('ui');
const playersEl=document.getElementById('players'); const diceEl=document.getElementById('dice'); const turnEl=document.getElementById('turn'); const phaseEl=document.getElementById('phase'); const logEl=document.getElementById('log');
const rollBtn = document.getElementById('roll');

let ME="", MYCOLOR="red", gameRef=null, IS_HOST=false;
let LOCAL_BARR_ADDS = new Set(); // affichage optimiste des barricades pos√©es
let LOCAL_PLACE_DONE = false; // on ferme la phase de placement localement

function blankState(){return{host:"",started:false,order:[],turnIndex:0,dice:0,winner:"",players:{},colors:{red:false,blue:false,green:false,yellow:false},barricades:[]}};
function ensure(st){ if(!st) st=blankState(); st.players=st.players||{}; st.colors=st.colors||{red:false,blue:false,green:false,yellow:false}; st.order=st.order||[]; st.barricades=st.barricades||[]; return st; }
function log(t){ logEl.textContent = t+"\\n"+logEl.textContent; }

// MENU actions
mCreate.onclick = async ()=>{ const id=mGame.value.trim(), name=mName.value.trim(), color=mColor.value; if(!id||!name) return alert("Pseudo + code");
  ME=name; MYCOLOR=color; IS_HOST=true; gameRef=ref(db,"games/"+id);
  await set(gameRef, blankState());
  await runTransaction(gameRef,(st)=>{ st=ensure(st); st.host=name; st.players[name]={color,pawns:Array.from({length:5}).map(()=>({pos:"home",atHome:true})),won:false}; st.colors[color]=true; st.order=[name]; return st; });
  subscribe(id); lobby.style.display="block";
};
mJoin.onclick = async ()=>{ const id=mGame.value.trim(), name=mName.value.trim(), color=mColor.value; if(!id||!name) return alert("Pseudo + code");
  ME=name; MYCOLOR=color; IS_HOST=false; gameRef=ref(db,"games/"+id);
  await runTransaction(gameRef,(st)=>{ st=ensure(st); if(st.started){alert("Partie d√©j√† d√©marr√©e");return;} if(st.players[name]){alert("Pseudo d√©j√† pris");return;} if(st.colors[color]){alert("Couleur d√©j√† prise");return;} st.players[name]={color,pawns:Array.from({length:5}).map(()=>({pos:"home",atHome:true})),won:false}; st.colors[color]=true; st.order.push(name); return st; });
  subscribe(id); lobby.style.display="block";
};
mStart.onclick = async ()=>{ if(!IS_HOST) return;
  await runTransaction(gameRef,(st)=>{ st=ensure(st); if(Object.keys(st.players).length<2){alert("Au moins 2 joueurs"); return;} st.started=true; st.turnIndex=0; st.dice=0; st.winner=""; st.barricades=[...BARRS]; st._mustPlaceBarricade=false; st._placer=""; return st; });
};

function subscribe(id){
  onValue(ref(db,"games/"+id),(snap)=>{
    const st=ensure(snap.val());

    // nettoie les ajouts optimistes une fois qu'ils sont refl√©t√©s c√¥t√© serveur
    if(st.barricades && st.barricades.length){
      for(const b of [...LOCAL_BARR_ADDS]){
        if(st.barricades.includes(b)) LOCAL_BARR_ADDS.delete(b);
      }
    }

    // version rendue : si c'est √† moi de placer mais j'ai d√©j√† plac√© localement, masque la phase
    let RST = st;
    if(st._mustPlaceBarricade && st._placer===ME && LOCAL_PLACE_DONE){
      RST = Object.assign({}, st, {_mustPlaceBarricade:false, _placer:""});
    }
    if(!st._mustPlaceBarricade){ LOCAL_PLACE_DONE = false; }

    for(const o of [...mColor.options]) o.disabled = !!st.colors[o.value];
    lobbyList.innerHTML=""; Object.entries(st.players).forEach(([n,p])=>{ const d=document.createElement('div'); d.className='tag'; d.innerHTML=`<span class="dot" style="background:${COLORS[p.color]}"></span>${n}`; lobbyList.appendChild(d); });
    if(RST.started){ menu.style.display="none"; game.style.display="block"; }
    drawState(RST);
    const myTurn = RST.order[RST.turnIndex]===ME;
    const canRoll = RST.started && myTurn && !RST._mustPlaceBarricade && (!RST.dice || RST.dice===0);
    rollBtn.disabled = !canRoll; rollBtn.style.opacity = canRoll ? "1" : ".5";
    if(RST._mustPlaceBarricade && st._placer===ME){ phaseEl.textContent = "Place une barricade noire sur une case libre"; showBarricadeTargets(RST); }
    else { phaseEl.textContent = ""; enableTurn(RST); }

    // Passage automatique du tour si bloqu√©
    autoSkipIfStuck(RST);
  });
}

// Draw
function drawEdges(){ G_E.innerHTML=""; for(const [a,ns] of Object.entries(ADJ_SAFE)){ const A=NODE_BY_ID[a]; if(!A) continue; ns.forEach(b=>{ if(a>b) return; const B=NODE_BY_ID[b]; if(!B) return; const L=document.createElementNS("http://www.w3.org/2000/svg","line"); L.setAttribute("x1",A.x); L.setAttribute("y1",A.y); L.setAttribute("x2",B.x); L.setAttribute("y2",B.y); L.setAttribute("class","edge"); G_E.appendChild(L); }); } }
function drawNodes(){ G_N.innerHTML=""; for(const n of NODES){ const c=document.createElementNS("http://www.w3.org/2000/svg","circle"); c.setAttribute("cx",n.x); c.setAttribute("cy",n.y); c.setAttribute("r","22"); c.setAttribute("class","node"); G_N.appendChild(c); } }
function drawHomes(){ G_H.innerHTML=""; for(const [col,arr] of Object.entries(HOMES)){ arr.forEach(p=>{ const c=document.createElementNS("http://www.w3.org/2000/svg","circle"); c.setAttribute("cx",p.x); c.setAttribute("cy",p.y); c.setAttribute("r","18"); c.setAttribute("fill",COLORS[col]); G_H.appendChild(c); }); } }
function drawBarricades(list){ (list||[]).forEach(id=>{ const n=NODE_BY_ID[id]; if(!n) return; const b=document.createElementNS("http://www.w3.org/2000/svg","circle"); b.setAttribute("cx",n.x); b.setAttribute("cy",n.y); b.setAttribute("r","18"); b.setAttribute("class","barricade"); G_P.appendChild(b); }); }

function occByPlayer(players){ const map = new Map(); for(const [name,pl] of Object.entries(players)){ pl.pawns.forEach(p=>{ if(!p.atHome) map.set(p.pos, name); }); } return map; }
function occSet(players){ return new Set([...occByPlayer(players).keys()]); }

function drawPawns(st){ for(const [name,pl] of Object.entries(st.players)){ for(let i=0;i<pl.pawns.length;i++){ const p=pl.pawns[i]; let x,y; if(p.atHome){ const arr=HOMES[pl.color]; const spot=arr[Math.min(i,arr.length-1)]; x=spot.x; y=spot.y; } else { const n=NODE_BY_ID[p.pos]; if(!n) continue; x=n.x; y=n.y; } const c=document.createElementNS("http://www.w3.org/2000/svg","circle"); c.setAttribute("cx",x); c.setAttribute("cy",y); c.setAttribute("r","21"); c.setAttribute("fill",COLORS[pl.color]); c.setAttribute("class","pawn"); G_P.appendChild(c); const t=document.createElementNS("http://www.w3.org/2000/svg","text"); t.setAttribute("x",x); t.setAttribute("y",y+4); t.setAttribute("text-anchor","middle"); t.setAttribute("font-size","10"); t.textContent=(i+1); G_P.appendChild(t); } } }

function drawState(st){ 
  playersEl.innerHTML=""; Object.entries(st.players).forEach(([n,p])=>{ const d=document.createElement('div'); d.className='tag'; d.innerHTML=`<span class="dot" style="background:${COLORS[p.color]}"></span>${n}`; playersEl.appendChild(d); });
  diceEl.textContent="D√© : "+(st.dice||"‚Äî"); 
  const myTurn = st.order[st.turnIndex]===ME; turnEl.textContent=(st.order[st.turnIndex]||"‚Äî")+(myTurn?" (√† toi)":""); 
  G_E.innerHTML=""; G_N.innerHTML=""; G_H.innerHTML=""; G_P.innerHTML=""; G_UI.innerHTML="";
  const mergedBarr = Array.from(new Set([...(st.barricades||[]), ...LOCAL_BARR_ADDS]));
  drawEdges(); drawNodes(); drawHomes(); drawBarricades(mergedBarr); drawPawns(st); 
}

// Reach: exact-N steps, only barricades block pass-through; last step cannot land on own pawn
function exactReachRules(start, steps, passBlocked, finalForbidden){ 
  const res=new Set();
  function dfs(cur, remaining, visited){
    if(remaining===0){ res.add(cur); return; }
    for(const nxt of (ADJ_SAFE[cur]||[])){ 
      if(visited.has(nxt)) continue;
      if(remaining>1){ // traversal step
        if(passBlocked.has(nxt)) continue; // barricades only
        visited.add(nxt); dfs(nxt, remaining-1, visited); visited.delete(nxt);
      } else { // last step
        if(finalForbidden.has(nxt)) continue; // own pawn forbidden
        visited.add(nxt); dfs(nxt, 0, visited); visited.delete(nxt);
      }
    }
  }
  const v=new Set([start]); dfs(start, steps, v);
  return [...res];
}


// --- D√©tection "aucun coup possible" + passage de tour auto ---

function hasAnyLegalMove(st, playerName) {
  const pl = st.players[playerName];
  if (!pl) return false;
  const dice = st.dice || 0;
  if (dice <= 0) return false;

  const myOcc = new Set(pl.pawns.filter(p => !p.atHome).map(p => p.pos));
  const barrSet = new Set(st.barricades || []);
  const globalOcc = occSet(st.players);
  const entry = ENTRY[pl.color];

  for (let i = 0; i < pl.pawns.length; i++) {
    const p = pl.pawns[i];
    if (p.atHome) {
      const steps = dice - 1; // la case d‚Äôentr√©e compte pour 1 pas
      if (steps === 0) {
        if (!globalOcc.has(entry) && !barrSet.has(entry)) return true;
      } else if (steps > 0) {
        const targets = exactReachRules(entry, steps, barrSet, myOcc);
        if (targets.length > 0) return true;
      }
    } else {
      const targets = exactReachRules(p.pos, dice, barrSet, myOcc);
      if (targets.length > 0) return true;
    }
  }
  return false;
}

function autoSkipIfStuck(st) {
  if (st.order[st.turnIndex] !== ME) return;
  if (!st.started) return;
  if (st._mustPlaceBarricade) return;
  if (!st.dice || st.dice === 0) return;

  if (hasAnyLegalMove(st, ME)) return;

  runTransaction(gameRef, (cur) => {
    cur = ensure(cur);
    if (cur.order[cur.turnIndex] !== ME) return cur;
    if (cur._mustPlaceBarricade) return cur;
    if (!cur.dice || cur.dice === 0) return cur;

    if (hasAnyLegalMove(cur, ME)) return cur;

    cur.dice = 0;
    cur.turnIndex = (cur.turnIndex + 1) % cur.order.length;
    return cur;
  });

  log("Aucun d√©placement possible : tour pass√© automatiquement.");
}


// Roll: only once per turn, not during barricade placement
rollBtn.onclick = async ()=>{ await runTransaction(gameRef,(st)=>{ st=ensure(st); if(!st.started) return st; if(st.order[st.turnIndex]!==ME) return st; if(st._mustPlaceBarricade) return st; if(st.dice && st.dice>0) return st; st.dice=Math.floor(Math.random()*6)+1; return st; }); };

let currentSelect = null;

// --- MODIFICATIONS APPLIQU√âES ICI ---
function addOriginHalo(x,y,onclick){ 
  const o=document.createElementNS("http://www.w3.org/2000/svg","circle"); 
  o.setAttribute("cx",x); 
  o.setAttribute("cy",y); 
  o.setAttribute("r","26"); 
  o.setAttribute("class","hint-origin"); 
  o.onclick = onclick;
  // Ajout des gestionnaires pour garantir le clic sur desktop
  o.onmousedown = (e) => { e.preventDefault(); e.stopPropagation(); onclick(); };
  o.ontouchstart = (e) => { e.preventDefault(); e.stopPropagation(); onclick(); };
  G_UI.appendChild(o); 
}

function addSelectRing(x,y){ const s=document.createElementNS("http://www.w3.org/2000/svg","circle"); s.setAttribute("cx",x); s.setAttribute("cy",y); s.setAttribute("r","30"); s.setAttribute("class","select"); s.setAttribute("data-role","select-ring"); G_UI.appendChild(s); }
function clearTargets(){ [...svg.querySelectorAll(".hint-target,[data-role='select-ring']")].forEach(n=>n.remove()); }

function addTargetHalo(x,y,onclick){ 
  const c=document.createElementNS("http://www.w3.org/2000/svg","circle"); 
  c.setAttribute("cx",x); 
  c.setAttribute("cy",y); 
  c.setAttribute("r","26"); 
  c.setAttribute("class","hint-target"); 
  c.onclick = onclick;
  // Ajout des gestionnaires pour garantir le clic sur desktop
  c.onmousedown = (e) => { e.preventDefault(); e.stopPropagation(); onclick(); };
  c.ontouchstart = (e) => { e.preventDefault(); e.stopPropagation(); onclick(); };
  G_UI.appendChild(c); 
}
// --- FIN DES MODIFICATIONS ---

function addTargetHaloWithLabel(x,y,label,onclick){
  addTargetHalo(x,y,onclick);
  const t=document.createElementNS("http://www.w3.org/2000/svg","text");
  t.setAttribute("x",x);
  t.setAttribute("y",y-30);
  t.setAttribute("text-anchor","middle");
  t.setAttribute("font-size","11");
  t.setAttribute("fill","#8a5a2b");
  t.textContent=label;
  G_UI.appendChild(t);
}


// ---------- Tour : s√©lection et d√©placements ----------

function enableTurn(st){
  // si pas √† moi de jouer, ou pas de d√©, ou phase barricade -> rien
  if(st.order[st.turnIndex]!==ME) return;
  if(!st.dice || st.dice===0) return;
  if(st._mustPlaceBarricade) return;

  clearTargets();
  currentSelect = null;

  const my = st.players[ME];
  const myOcc = new Set();
  my.pawns.forEach(p=>{ if(!p.atHome) myOcc.add(p.pos); });

  // occupations globales pour interdire de finir sur son propre pion
  const globalOcc = occSet(st.players);

  // barricades bloquantes
  const barrSet = new Set(st.barricades||[]);

  // 1) origins s√©lectionnables
  // - un pion sur le plateau
  // - OU sortir de la maison vers ENTRY si libre
  

my.pawns.forEach((p,idx)=>{
    if(p.atHome){
      // --- NEW: rendre chaque pion en base cliquable comme sur le plateau ---
      const entry = ENTRY[my.color];
      const myEndsForbidden = new Set(my.pawns.filter(pp=>!pp.atHome).map(pp=>pp.pos));
      const steps = Math.max(0, (st.dice||0) - 1);

      // calcule les destinations possibles pour ce pion de base
      let targets = [];
      if (steps === 0) {
        const occ = new Set([...(Object.values(st.players||{}).flatMap(pl => (pl.pawns||[]).filter(pp=>!pp.atHome).map(pp=>pp.pos)))]);
        const barrSetEntry = new Set(st.barricades||[]);
        if (!occ.has(entry) && !barrSetEntry.has(entry)) targets = [entry];
      } else {
        targets = exactReachRules(entry, steps, new Set(st.barricades||[]), myEndsForbidden);
      }

      // S'il y a au moins une destination l√©gale, on rend le pion en base s√©lectionnable
      if (targets.length > 0) {
        const spot = HOMES[my.color][Math.min(idx, HOMES[my.color].length-1)];
        addOriginHalo(spot.x, spot.y, ()=>{
          clearTargets();
          addSelectRing(spot.x, spot.y);
          targets.forEach(id=>{
            const t = NODE_BY_ID[id];
            addTargetHalo(t.x, t.y, ()=> movePawnFromHomeToTarget(st, idx, id));
          });
        });
      }
    } else {
      const n = NODE_BY_ID[p.pos];
      addOriginHalo(n.x,n.y,()=>{
        clearTargets();
        addSelectRing(n.x,n.y);
        const targets = exactReachRules(p.pos, st.dice, barrSet, myOcc);
        targets.forEach(id=>{
          const t = NODE_BY_ID[id];
          addTargetHalo(t.x,t.y,()=> movePawnOnBoard(st, idx, id));
        });
      });
    }
  });
}

function movePawnFromHome(st, pawnIndex, entryId){
  // sortie de maison = consomme le d√© entier (r√®gle simplifi√©e)
  transactMove(st, pawnIndex, "home", entryId);
}

function movePawnOnBoard(st, pawnIndex, destId){
  const p = st.players[ME].pawns[pawnIndex];
  transactMove(st, pawnIndex, p.pos, destId);
}

function movePawnFromHomeToTarget(st, pawnIndex, destId){
  // Utilise la transaction g√©n√©rique pour passer de la maison √† la destination
  transactMove(st, pawnIndex, "home", destId);
}


function transactMove(st, pawnIndex, from, to){
  // Optimistic UI : rien √† faire ici (le rendu se base sur snapshot), on √©crit directement en base via transaction.
  runTransaction(gameRef, (cur)=>{
    cur = ensure(cur);
    if(cur.order[cur.turnIndex]!==ME) return cur;
    if(cur._mustPlaceBarricade) return cur;
    if(!cur.dice || cur.dice===0) return cur;

    const me = cur.players[ME];
    if(!me) return cur;
    const pawn = me.pawns[pawnIndex];
    if(!pawn) return cur;

    // v√©rifs
    const occ = occSet(cur.players);
    const barrSet = new Set(cur.barricades||[]);
    if(to==="home"){
      // not used here
    } else {
      // interdire d'atterrir sur son propre pion
      if(occ.has(to) && occByPlayer(cur.players).get(to)===ME) return cur;
    }

    // capture adversaire : le renvoyer √† la maison
    if(occ.has(to)){
      const owner = occByPlayer(cur.players).get(to);
      if(owner && owner!==ME){
        const opp = cur.players[owner];
        const idx = (opp.pawns||[]).findIndex(pp=>!pp.atHome && pp.pos===to);
        if(idx>=0){
          opp.pawns[idx] = {pos:"home", atHome:true};
          log("Tu renvoies un pion de "+owner+" √† la maison");
        }
      }
    }

    // d√©placer mon pion
    if(pawn.atHome){
      pawn.atHome = false;
      pawn.pos = to;
    } else {
      pawn.pos = to;
    }

    // si on est all√© sur une barricade -> la retirer et d√©clencher la phase de placement
    if(barrSet.has(to)){
      cur.barricades = (cur.barricades||[]).filter(id=>id!==to);
      cur._mustPlaceBarricade = true;
      cur._placer = ME;
      // le tour reste en attente de placement -> on NE change PAS turnIndex ni dice
    } else {
      // fin de tour classique
      cur.dice = 0;
      cur.turnIndex = (cur.turnIndex + 1) % cur.order.length;
    }

    return cur;
  });
}

// ---------- Placement de barricade (apr√®s capture) ----------

function showBarricadeTargets(st){
  clearTargets();
  // Occupations et barricades actuelles (merge avec optimiste)
  const occ = occSet(st.players);
  const barrSet = new Set([...(st.barricades||[]), ...LOCAL_BARR_ADDS]);
  const bottomY = Math.max(...NODES.map(n=>n.y)); // Exclure la premi√®re ligne (tout en bas)

  // Cibles = tous les noeuds non occup√©s, non barricad√©s
  NODES.forEach(n=>{
    const id = n.id;
    if(n.y === bottomY) return; // exclure la premi√®re ligne
    // Interdire les maisons (visuelles) : on consid√®re qu'on ne pose que sur les cercles du chemin
    if(occ.has(id)) return;
    if(barrSet.has(id)) return;
    addTargetHalo(n.x,n.y,()=> placeBarricade(st, id));
  });
}

function placeBarricade(st, nodeId){
  const node = getNodeById(nodeId);
  const bottomY = Math.max(...NODES.map(n=>n.y));
  if(node && node.y === bottomY){
    log("Placement de barricade interdit sur la premi√®re ligne.");
    return;
  }


  // Optimistic: afficher tout de suite
  LOCAL_BARR_ADDS.add(nodeId);
  LOCAL_PLACE_DONE = true;
  drawState(Object.assign({}, st, { barricades: [...(st.barricades||[]), nodeId] }));

  // Transaction serveur atomique: ajoute barricade, ferme phase, passe le tour et remet le d√© √† 0
  runTransaction(gameRef, (cur)=>{
    cur = ensure(cur);
    if(!cur._mustPlaceBarricade || cur._placer!==ME) return cur;

    const occ = occSet(cur.players);
    const barrSet = new Set(cur.barricades||[]);
    const node = getNodeById(nodeId);
    const bottomY = Math.max(...NODES.map(n=>n.y));
    // valide c√¥t√© serveur
    if(occ.has(nodeId)) return cur;
    if(barrSet.has(nodeId)) return cur;
    if(node && node.y === bottomY) return cur; // interdit sur premi√®re ligne

    cur.barricades = [...(cur.barricades||[]), nodeId];
    cur._mustPlaceBarricade = false;
    cur._placer = "";
    cur.dice = 0;
    cur.turnIndex = (cur.turnIndex + 1) % cur.order.length;
    return cur;
  });
}

// --- Zoom only (wheel + pinch), no pan ---
let view = { x:0, y:0, w:1090, h:1300 };
function applyView(){ svg.setAttribute('viewBox', `${view.x} ${view.y} ${view.w} ${view.h}`); }
applyView();

svg.addEventListener('wheel', e=>{ e.preventDefault(); const scale = (e.deltaY>0)? 1.1 : 0.9; const mx = view.x + (e.offsetX/svg.clientWidth)*view.w; const my = view.y + (e.offsetY/svg.clientHeight)*view.h; view.w*=scale; view.h*=scale; view.x = mx - (e.offsetX/svg.clientWidth)*view.w; view.y = my - (e.offsetY/svg.clientHeight)*view.h; applyView(); }, {passive:false});

const pointers = new Map(); let pinchPrevDist = null;
svg.addEventListener('pointerdown', e=>{ pointers.set(e.pointerId, e); svg.setPointerCapture(e.pointerId); });
svg.addEventListener('pointermove', e=>{ if(!pointers.has(e.pointerId)) return; pointers.set(e.pointerId, e); if(pointers.size===2){ const [p1,p2] = [...pointers.values()]; const dx = p2.clientX - p1.clientX; const dy = p2.clientY - p1.clientY; const dist = Math.hypot(dx,dy); const midX = (p1.clientX + p2.clientX)/2; const midY = (p1.clientY + p2.clientY)/2; const mx = view.x + (midX/svg.clientWidth)*view.w; const my = view.y + (midY/svg.clientHeight)*view.h; if(pinchPrevDist!==null && dist>0){ const scale = pinchPrevDist/dist; view.w*=scale; view.h*=scale; view.x = mx - (midX/svg.clientWidth)*view.w; view.y = my - (midY/svg.clientHeight)*view.h; applyView(); } pinchPrevDist = dist; } });
function endPtr(e){ pointers.delete(e.pointerId); if(pointers.size<2) pinchPrevDist=null; }
svg.addEventListener('pointerup', endPtr); svg.addEventListener('pointercancel', endPtr); svg.addEventListener('pointerleave', endPtr);



// === BEGIN: Victory watcher (non-intrusive) ===

// 1) Compute top goal node dynamically
function __getTopGoalNodeId(){
  try{
    if (!Array.isArray(NODES) || !NODES.length) return null;
    let top = NODES[0];
    for (let i=1;i<NODES.length;i++){
      if (NODES[i] && typeof NODES[i].y === 'number' && NODES[i].y < top.y) top = NODES[i];
    }
    return top.id || null;
  }catch(e){ return null; }
}
const __TOP_NODE_ID = __getTopGoalNodeId();

// 2) Overlay elements (added in HTML)
const __winOverlay = document.getElementById('winOverlay');
const __winTitle   = document.getElementById('winTitle');
const __winMsg     = document.getElementById('winMsg');
const __winClose   = document.getElementById('winClose');
if (__winClose) __winClose.onclick = ()=>{ __winOverlay.style.display = 'none'; };

function __showVictoryOverlay(__winnerName){
  if (!__winOverlay || !__winTitle || !__winMsg) return;
  __winTitle.textContent = `Victoire de ${__winnerName}`;
  __winMsg.textContent = "Si Camille a gagn√©, c'est logique, elle est trop forte. Si elle a perdu, sachez qu'elle est en train de vous insulter";
  __winOverlay.style.display = 'flex';
  const __roll = document.getElementById('rollBtn');
  if (__roll) __roll.disabled = true;
}

// 3) Attach watcher once when gameRef exists
let __victoryWatcherAttached = false;

function __attachVictoryWatcherWhenReady(){
  if (__victoryWatcherAttached) return;

  if (typeof gameRef === 'undefined' || !gameRef) {
    setTimeout(__attachVictoryWatcherWhenReady, 250);
    return;
  }
  __victoryWatcherAttached = true;

  onValue(gameRef, (snap)=>{
    const st = (typeof ensure === 'function') ? ensure(snap.val()) : (snap.val() || {});
    if (!st || !st.players) return;

    // Already a winner? show
    if (st.winner && String(st.winner).length){
      __showVictoryOverlay(st.winner);
      return;
    }

    const goal = __TOP_NODE_ID;
    if (!goal) return;

    let reachedBy = "";
    for (const [name, pl] of Object.entries(st.players || {})){
      const pawns = pl && Array.isArray(pl.pawns) ? pl.pawns : [];
      if (pawns.some(p => p && !p.atHome && p.pos === goal)){
        reachedBy = name;
        break;
      }
    }

    if (reachedBy){
      // Commit winner only once
      try{
        runTransaction(gameRef, (cur)=>{
          cur = (typeof ensure === 'function') ? ensure(cur) : (cur || {});
          if (!cur.winner) {
            cur.winner = reachedBy;
            cur.dice = 0;
          }
          return cur;
        });
      }catch(e){
        console.error("Victory runTransaction error", e);
      }
    }
  });
}

// start waiting
__attachVictoryWatcherWhenReady();

// Also retry on visibility regain (in case of reloads)
document.addEventListener('visibilitychange', ()=>{
  if (document.visibilityState === 'visible') __attachVictoryWatcherWhenReady();
});

// === END: Victory watcher (non-intrusive) ===








// === BEGIN: Desktop click-catcher helpers (v2 with coord mapping) ===
(function(){
  if (window.__homeClickCatchersInstalledV2) return;
  window.__homeClickCatchersInstalledV2 = true;

  const CATCHER_SIZE = 36; // a bit larger for easier desktop clicking

  function getBoardHost(){
    // Try common containers: #game, canvas inside it, or any canvas/svg on page
    const game = document.getElementById('game') || document.body;
    const surface = game.querySelector('canvas, svg') || document.querySelector('canvas, svg');
    return surface || game;
  }

  function getBoardRect(){
    const host = getBoardHost();
    if (!host) return null;
    return host.getBoundingClientRect();
  }

  // Compute linear mapping from game coords (NODES.x/y) to pixels using min/max of NODES and the current board rect
  function computeMapper(){
    try{
      if (!Array.isArray(NODES) || !NODES.length) return null;
      let minX=NODES[0].x, maxX=NODES[0].x, minY=NODES[0].y, maxY=NODES[0].y;
      for (let i=1;i<NODES.length;i++){
        const n = NODES[i];
        if (!n) continue;
        if (n.x < minX) minX = n.x;
        if (n.x > maxX) maxX = n.x;
        if (n.y < minY) minY = n.y;
        if (n.y > maxY) maxY = n.y;
      }
      const rect = getBoardRect();
      if (!rect) return null;
      const sx = (maxX - minX) || 1;
      const sy = (maxY - minY) || 1;
      const kx = rect.width / sx;
      const ky = rect.height / sy;
      // Many boards use equal scale; pick min to stay inside
      const k = Math.min(kx, ky);
      // Centering offsets if aspect ratios differ
      const offsetX = rect.left + window.scrollX + (rect.width - k * sx)/2;
      const offsetY = rect.top  + window.scrollY + (rect.height - k * sy)/2;
      return function toPx(pt){
        return {
          x: offsetX + (pt.x - minX) * k,
          y: offsetY + (pt.y - minY) * k
        };
      };
    }catch(e){ console.error("mapper error", e); return null; }
  }

  function placeClickCatcherAtGameCoord(coord, onhit){
    const map = computeMapper();
    if (!map) return;
    const p = map(coord);
    const div = document.createElement('div');
    div.className = 'home-click-catcher';
    div.style.position = 'absolute';
    div.style.left = (p.x - CATCHER_SIZE/2) + 'px';
    div.style.top  = (p.y - CATCHER_SIZE/2) + 'px';
    div.style.width = CATCHER_SIZE + 'px';
    div.style.height = CATCHER_SIZE + 'px';
    div.style.zIndex = 9998;
    div.style.background = 'transparent';
    div.style.pointerEvents = 'auto';
    div.style.touchAction = 'manipulation';

    ['click','pointerdown','mousedown','touchstart'].forEach(evt => {
      div.addEventListener(evt, (e)=>{
        try{ e.preventDefault(); e.stopPropagation(); }catch(_){}
        try{ onhit && onhit(); }catch(err){ console.error(err); }
      }, {passive:false});
    });

    document.body.appendChild(div);
  }

  function clearClickCatchers(){
    document.querySelectorAll('.home-click-catcher').forEach(el=>el.remove());
  }

  window.__placeHomeClickCatcherAtGameCoord = placeClickCatcherAtGameCoord;
  window.__clearHomeClickCatchers = clearClickCatchers;
})();
// === END: Desktop click-catcher helpers (v2 with coord mapping) ===




// === BEGIN: clearTargets wrapper to also clear click-catchers ===
(function(){
  if (window.__wrapClearTargetsInstalled) return;
  window.__wrapClearTargetsInstalled = true;
  if (typeof clearTargets === 'function'){
    const _orig = clearTargets;
    window.clearTargets = function(){
      try{ window.__clearHomeClickCatchers && window.__clearHomeClickCatchers(); }catch(_){}
      return _orig.apply(this, arguments);
    }
  }
})();
// === END: clearTargets wrapper ===

</script>
<style>
  #winOverlay{
    position:fixed;
    inset:0;
    display:none;
    align-items:center;
    justify-content:center;
    background:
      radial-gradient(circle at 20% 0%,rgba(251,146,60,.35) 0,transparent 45%),
      radial-gradient(circle at 80% 100%,rgba(59,130,246,.45) 0,transparent 55%),
      rgba(3,7,18,.95);
    z-index:9999;
  }

  #winBox{
    background:
      radial-gradient(circle at 0 0,rgba(251,146,60,.35) 0,transparent 55%),
      radial-gradient(circle at 100% 100%,rgba(34,197,94,.3) 0,transparent 55%),
      linear-gradient(145deg,#020617,#020617,#020617);
    border:1px solid rgba(148,163,184,.9);
    border-radius:22px;
    padding:22px 22px 18px;
    max-width:520px;
    width:90%;
    text-align:center;
    box-shadow:
      0 32px 80px rgba(0,0,0,1),
      0 0 0 1px rgba(15,23,42,.9);
    color:#e5e7eb;
  }

  #winBox h2{
    margin:0 0 8px;
    font-size:22px;
    letter-spacing:.16em;
    text-transform:uppercase;
  }

  #winBox h2::before{
    content:"üèÜ";
    margin-right:6px;
  }

  #winBox p{
    margin:0;
    font-size:14px;
    color:#e5e7eb;
    opacity:.9;
  }

  #winClose{
    margin-top:16px;
    padding:9px 22px;
    border-radius:999px;
    border:1px solid rgba(148,163,184,.9);
    background:
      radial-gradient(circle at 0 0,rgba(251,146,60,.35) 0,transparent 55%),
      linear-gradient(135deg,#111827,#020617);
    color:#e5e7eb;
    cursor:pointer;
    font-size:13px;
    font-weight:600;
    text-shadow:0 1px 1px rgba(15,23,42,.9);
    transition:
      transform .08s ease,
      box-shadow .18s ease,
      border-color .18s ease,
      background .18s ease;
  }

  #winClose:hover{
    transform:translateY(-1px);
    box-shadow:
      0 5px 0 rgba(15,23,42,1),
      0 18px 36px rgba(0,0,0,.95);
    border-color:#fbbf24;
  }

  #winClose:active{
    transform:translateY(1px);
    box-shadow:
      0 1px 0 rgba(15,23,42,1),
      0 8px 16px rgba(0,0,0,.9) inset;
  }
</style>
<div id="winOverlay" role="dialog" aria-modal="true" aria-labelledby="winTitle">
  <div id="winBox">
    <h2 id="winTitle">Victoire !</h2>
    <p id="winMsg">Si Camille a gagn√©, c'est logique, elle est trop forte. Si elle a perdu, c'est simplement que vous avez eu de la chance</p>
    <button id="winClose">OK</button>
  </div>
</div>
</body>
</html>
