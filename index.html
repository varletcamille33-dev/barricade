<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Barricade / Malefiz â€” en ligne (4 joueurs)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --cell: 56px;
      --gap: 6px;
    }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin:0; background:#0b1220; color:#e8ecf1; }
    header { padding:14px 18px; background:#0e1730; border-bottom:1px solid #1f2a44; display:flex; align-items:center; gap:14px; flex-wrap:wrap; }
    header h1 { font-size:18px; margin:0; font-weight:650; }
    main { display:grid; grid-template-columns: 1fr 340px; gap:16px; padding:16px; }
    #boardWrap { overflow:auto; }
    #board {
      width: calc(var(--cell) * 9 + var(--gap) * 8);
      display:grid;
      grid-template-columns: repeat(9, var(--cell));
      gap: var(--gap);
      margin: 0 auto;
      background:#0e1730;
      padding:10px;
      border-radius:14px;
      border:1px solid #1f2a44;
      box-shadow: 0 10px 30px rgba(0,0,0,0.25);
    }
    .cell {
      width: var(--cell);
      height: var(--cell);
      border-radius:10px;
      background:#0f1a3a;
      border:1px solid #1f2a44;
      display:flex; align-items:center; justify-content:center;
      position:relative;
      user-select:none;
    }
    .path { background:#13224a; }
    .path::after {
      content:""; position:absolute; inset:6px; border:1px dashed #33518e; border-radius:8px; opacity:.7;
    }
    .goal { background:#2c7e2f !important; border-color:#46b44a; }
    .goal::after { border-color:#92db95; }
    .barricade {
      position:absolute; inset:9px; background:#3a3a3a; border:2px solid #aaaaaa;
      border-radius:6px; display:flex; align-items:center; justify-content:center; color:#fff; font-weight:800; letter-spacing:1px;
    }
    .home { background:#111a34; border-style:dotted; }
    .homeLabel { position:absolute; bottom:6px; right:6px; font-size:10px; opacity:.7; }
    .pawn {
      width: 28px; height: 28px; border-radius:50%; display:flex; align-items:center; justify-content:center;
      color:#fff; font-weight:800; text-shadow:0 1px 1px rgba(0,0,0,.5);
      border:2px solid rgba(255,255,255,.25);
      box-shadow: 0 2px 6px rgba(0,0,0,.5);
      cursor: pointer;
    }
    .owned { outline: 2px solid #fff; outline-offset:2px; }
    .hint { position:absolute; inset:6px; border:2px solid #f6c35c; border-radius:8px; pointer-events:none; }
    .clickable { cursor:pointer; box-shadow: 0 0 0 2px #f6c35c inset; }
    #side {
      background:#0e1730; border:1px solid #1f2a44; border-radius:14px; padding:14px; display:flex; flex-direction:column; gap:12px;
    }
    #controls button, #controls input, #controls select { font: inherit; border-radius:10px; border:1px solid #2a3b66; background:#102046; color:#e8ecf1; padding:8px 10px; }
    #controls button.primary { background:#2b6ae6; border-color:#2b6ae6; color:#fff; font-weight:700; }
    #players { display:flex; gap:8px; flex-wrap:wrap; }
    .tag { padding:4px 8px; border-radius:999px; border:1px solid #2a3b66; background:#0f1e42; font-size:12px; }
    .tag .dot { display:inline-block; width:10px; height:10px; border-radius:50%; margin-right:6px; vertical-align:-1px; }
    #log { background:#0f1e42; border:1px solid #2a3b66; border-radius:10px; padding:8px; height:200px; overflow:auto; white-space:pre-wrap; font-size:12px; }
    a.small { color:#9db7ff; text-decoration:underline; font-size:12px; }
  </style>
</head>
<body>
  <header>
    <h1>ðŸ§± Barricade / Malefiz â€” multi en ligne (Firebase)</h1>
    <div id="live"></div>
  </header>

  <main>
    <div id="boardWrap">
      <div id="board"></div>
    </div>

    <aside id="side">
      <section id="controls">
        <div style="display:flex; gap:6px; flex-wrap:wrap;">
          <input id="gameId" placeholder="code de partie (ex: famille1)" style="flex:1; min-width:160px;" />
          <button id="newGame">Nouvelle partie</button>
          <button id="joinGame" class="primary">Rejoindre</button>
        </div>
        <div style="display:flex; gap:6px; flex-wrap:wrap; margin-top:6px;">
          <input id="nameInput" placeholder="ton pseudo" style="flex:1;" />
          <select id="colorInput">
            <option value="red">rouge</option>
            <option value="blue">bleu</option>
            <option value="green">vert</option>
            <option value="yellow">jaune</option>
          </select>
        </div>
        <hr style="border-color:#1f2a44;">
        <div style="display:flex; gap:6px; flex-wrap:wrap;">
          <button id="roll">ðŸŽ² Lancer le dÃ©</button>
          <div id="dice" style="padding:8px 10px; border-radius:10px; border:1px solid #2a3b66;">DÃ©: â€”</div>
        </div>
        <div style="margin-top:6px;">Tour: <strong id="turn">â€”</strong></div>
        <div style="margin-top:4px;">Joueurs (max 4) :</div>
        <div id="players"></div>
        <div style="margin-top:8px;"><a class="small" href="#" id="copyLink">Copier le lien de cette partie</a></div>
      </section>

      <section>
        <div><strong>Journal</strong></div>
        <div id="log"></div>
      </section>

      <section>
        <div style="font-size:12px; opacity:.8;">
          <p><strong>Config Firebase :</strong> ouvre <code>index.html</code> et remplace le bloc <code>firebaseConfig</code> par celui de ton projet Firebase (Realtime Database en mode test).</p>
        </div>
      </section>
    </aside>
  </main>

  <script type="module">
    /**
     * Barricade/Malefiz online (simplified-but-faithful board)
     * - Up to 4 players (red, blue, green, yellow)
     * - 5 pawns each, start from homes, move along defined path graph
     * - Barricades block; if you land on a barricade, you take it and must place it elsewhere on the path (not on home/goal)
     * - You can capture opponents (send captured pawn back to its home queue)
     * - First pawn to reach the goal wins
     * - Realtime sync using Firebase Realtime Database
     */

    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-app.js";
    import {
      getDatabase, ref, child, get, onValue, set, update, runTransaction
    } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-database.js";

    // ====== âš ï¸ Replace with YOUR Firebase project config (console Firebase â†’ Web app) ======
    const firebaseConfig = {
      apiKey: "REMPLACE_MOI",
      authDomain: "REMPLACE_MOI.firebaseapp.com",
      databaseURL: "https://REMPLACE_MOI-default-rtdb.firebaseio.com",
      projectId: "REMPLACE_MOI"
      // (les autres champs ne sont pas nÃ©cessaires ici)
    };
    // =======================================================================================

    const app = initializeApp(firebaseConfig);
    const db  = getDatabase(app);

    const boardEl   = document.getElementById('board');
    const logEl     = document.getElementById('log');
    const diceEl    = document.getElementById('dice');
    const turnEl    = document.getElementById('turn');
    const playersEl = document.getElementById('players');
    const copyLink  = document.getElementById('copyLink');

    const newBtn = document.getElementById('newGame');
    const joinBtn = document.getElementById('joinGame');
    const rollBtn = document.getElementById('roll');
    const gameIdInput = document.getElementById('gameId');
    const nameInput = document.getElementById('nameInput');
    const colorInput = document.getElementById('colorInput');

    const urlParams = new URLSearchParams(location.search);
    if(urlParams.get('game')) gameIdInput.value = urlParams.get('game');

    copyLink.addEventListener('click', (e)=>{
      e.preventDefault();
      const id = gameIdInput.value.trim() || "partie";
      const url = location.origin + location.pathname + "?game=" + encodeURIComponent(id);
      navigator.clipboard.writeText(url);
      toast("Lien copiÃ© : " + url);
    });

    function toast(t){ log(t); }

    function log(t){
      const time = new Date().toLocaleTimeString();
      logEl.textContent = `[${time}] ${t}\n` + logEl.textContent;
    }

    // ===== Board definition (9x9) with a faithful-ish Malefiz path graph =====
    // We'll mark which cells are path (playable), homes for colors, and goal.
    // Coordinates are "r-c" (0..8). Goal at top center "0-4".

    const rows = 9, cols = 9;
    const GOAL = "0-4";

    // Mark path cells (a zigzag/ladder style resembling the real Malefiz board)
    // This is a hand-crafted path network: adjacency list. Only cells in PATH are valid.
    // For readability, we list edges both ways.
    const PATH = new Set([
      // bottom area to top (a winding single main path with some side connections)
      "8-0","8-1","8-2","8-3","8-4","8-5","8-6","8-7","8-8",
      "7-8","6-8","5-8","4-8","3-8","2-8","1-8",
      "1-7","1-6","1-5","1-4","1-3","1-2","1-1",
      "2-1","3-1","4-1","5-1","6-1","7-1",
      "7-2","7-3","7-4","7-5","7-6","7-7",
      "6-7","5-7","4-7","3-7","2-7",
      "2-6","2-5","2-4","2-3",
      "3-3","4-3","5-3","6-3",
      "6-4","6-5",
      "5-5","4-5","3-5",
      "3-4","2-4b", // placeholder comment to help reading (no effect)
    ]);
    // In addition to the main winding, connect towards the goal via a narrow ladder:
    ["6-4","5-4","4-4","3-4","2-4","1-4","0-4"].forEach(p=>PATH.add(p));
    // Ensure neighbors continuity segments:
    ["8-4","7-4","6-4","5-4","4-4","3-4","2-4","1-4"].forEach(()=>{});

    // Define adjacency based on 4-neighborhood inside PATH
    const neighbors = {};
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const k = `${r}-${c}`;
        if(!PATH.has(k) && k!==GOAL) continue;
        neighbors[k] = [];
        [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dr,dc])=>{
          const nr=r+dr, nc=c+dc;
          const nk = `${nr}-${nc}`;
          if(nr>=0 && nr<rows && nc>=0 && nc<cols && (PATH.has(nk) || nk===GOAL)){
            neighbors[k].push(nk);
          }
        });
      }
    }

    // Homes (queues) for each color: 5 pawns each. We'll map them to off-board slots and entry cells.
    const HOMES = {
      red:   { slots: ["8-0","8-1","8-2","8-3","8-4"], entry:"8-4" },
      blue:  { slots: ["8-8","8-7","8-6","8-5","8-4"], entry:"8-4" },
      green: { slots: ["1-8","2-8","3-8","4-8","5-8"], entry:"5-8" },
      yellow:{ slots: ["1-1","2-1","3-1","4-1","5-1"], entry:"5-1" }
    };

    // Initial barricade positions on the path (not on homes nor goal).
    // We'll place a moderate number for good play.
    const INIT_BARRICADES = ["6-7","4-7","2-6","6-3","4-3","3-5","2-4","4-4"];

    // ===== UI grid creation =====
    const cells = new Map();
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const k = `${r}-${c}`;
        const div = document.createElement('div');
        div.className = 'cell' + (PATH.has(k) ? ' path' : '');
        if(k===GOAL){ div.classList.add('goal'); }
        // home labels
        for(const [col,info] of Object.entries(HOMES)){
          if(info.slots.includes(k)){ div.classList.add('home'); const lab=document.createElement('div'); lab.className='homeLabel'; lab.textContent=col; div.appendChild(lab); }
        }
        div.dataset.key = k;
        boardEl.appendChild(div);
        cells.set(k, div);
      }
    }

    // Helpers
    const COLORS = { red:"#e74b4b", blue:"#3a7bff", green:"#2fbf71", yellow:"#e5c14b" };

    function drawPawn(cellKey, color, label, owned=false){
      const el = document.createElement('div');
      el.className = 'pawn' + (owned? ' owned' : '');
      el.style.background = COLORS[color] || "#888";
      el.textContent = label;
      cells.get(cellKey).appendChild(el);
      return el;
    }

    function clearBoardLayers(){
      for(const [,el] of cells){
        // remove children dynamic (pawns, barricades, hints)
        [...el.querySelectorAll('.pawn,.barricade,.hint')].forEach(n=>n.remove());
      }
    }

    function placeBarricade(cellKey){
      const b = document.createElement('div');
      b.className = 'barricade';
      b.textContent = "B";
      cells.get(cellKey)?.appendChild(b);
    }

    function markHints(keys){
      keys.forEach(k=>{
        const h = document.createElement('div'); h.className='hint';
        cells.get(k)?.appendChild(h);
        cells.get(k)?.classList.add('clickable');
      });
    }
    function unmarkHints(){
      for(const [,el] of cells){ el.classList.remove('clickable'); [...el.querySelectorAll('.hint')].forEach(n=>n.remove()); }
    }

    // ===== Game state (Firebase) =====
    function blankState(){
      return {
        started: false,
        order: [],         // array of player ids (names)
        turnIndex: 0,
        dice: 0,
        goal: GOAL,
        barricades: INIT_BARRICADES,
        players: {
          // name: { color, pawns:[{pos, atHome:boolean}], won:boolean }
        },
        winner: ""
      };
    }

    // Movement helpers
    function shortestPaths(start, steps, blockedSet){
      // BFS across neighbors for exactly "steps" edges, avoiding blocked cells
      let frontier = new Set([start]);
      for(let s=0;s<steps;s++){
        const next = new Set();
        for(const k of frontier){
          for(const n of (neighbors[k]||[])){
            if(blockedSet.has(n)) continue;
            next.add(n);
          }
        }
        frontier = next;
      }
      return frontier;
    }

    function isOccupied(cellKey, allPawns){
      return allPawns.some(p=>p.pos===cellKey);
    }

    // ===== Client session =====
    let ME = ""; // player name
    let MYCOLOR = "red";
    let gameRef = null;

    newBtn.addEventListener('click', async ()=>{
      const id = prompt("Code de partie (ex: famille1)") || "demo";
      gameIdInput.value = id;
      const refPath = 'games/' + id;
      await set(ref(db, refPath), blankState());
      toast("Partie crÃ©Ã©e : " + id + ". Partage le lien en haut Ã  droite.");
    });

    joinBtn.addEventListener('click', async ()=>{
      const id = gameIdInput.value.trim();
      if(!id) return alert("Entre un code de partie.");
      const name = (nameInput.value || "").trim();
      if(!name) return alert("Entre un pseudo.");
      const color = colorInput.value;
      ME = name; MYCOLOR = color;

      gameRef = ref(db, 'games/'+id);
      // Try to add player atomically
      await runTransaction(gameRef, (state)=>{
        if(state==null) state = blankState();
        if(!state.players) state.players = {};
        if(Object.keys(state.players).length >= 4 && !state.players[name]){
          alert("La partie est pleine (4 joueurs).");
          return; // abort
        }
        if(!state.players[name]){
          state.players[name] = {
            color,
            pawns: Array.from({length:5}).map(()=>({ pos:"home", atHome:true })),
            won:false
          };
          if(!state.order.includes(name)) state.order.push(name);
        }
        return state;
      });

      // Subscribe
      onValue(gameRef, (snap)=>{
        const state = snap.val();
        if(!state) return;
        render(state);
      });

      toast("Rejoint la partie : " + id + " comme " + name + " ("+color+").");
    });

    rollBtn.addEventListener('click', async ()=>{
      if(!gameRef) return alert("Rejoins une partie d'abord.");
      await runTransaction(gameRef, (state)=>{
        if(!state) return state;
        const current = state.order[state.turnIndex] || "";
        if(current !== ME) return state; // not my turn
        state.dice = Math.floor(Math.random()*6)+1;
        return state;
      });
    });

    function allPawnsArray(players){
      const arr = [];
      for(const [name,pl] of Object.entries(players||{})){
        pl.pawns.forEach((p,i)=>arr.push({owner:name, color:pl.color, index:i, pos:p.pos, atHome:p.atHome}));
      }
      return arr;
    }

    function render(state){
      clearBoardLayers();
      // barricades
      (state.barricades||[]).forEach(b=>placeBarricade(b));

      // goal marker (already styled)

      // players & pawns
      playersEl.innerHTML = "";
      for(const [name,pl] of Object.entries(state.players||{})){
        const tag = document.createElement('div'); tag.className='tag';
        tag.innerHTML = `<span class="dot" style="background:${COLORS[pl.color]||"#888"}"></span>${name}`;
        playersEl.appendChild(tag);
        pl.pawns.forEach((p,i)=>{
          const cellKey = (p.atHome) ? HOMES[pl.color].slots[Math.min(i, HOMES[pl.color].slots.length-1)] : p.pos;
          const owned = (name===ME);
          drawPawn(cellKey, pl.color, i+1, owned);
        });
      }

      diceEl.textContent = "DÃ©: " + (state.dice || "â€”");
      const current = state.order[state.turnIndex] || "â€”";
      turnEl.textContent = current + (current===ME ? " (Ã  toi)" : "");

      // Interaction on my turn
      unmarkHints();
      if(current===ME && state.dice>0){
        // compute possible moves for my pawns
        const me = state.players[ME];
        if(!me) return;
        const allP = allPawnsArray(state.players);
        const occupied = new Set(allP.map(p=>p.pos));

        const blocked = new Set(state.barricades.concat(Array.from(occupied)));
        const myEntry = HOMES[me.color].entry;

        // For each pawn, compute destinations
        me.pawns.forEach((pawn, idx)=>{
          let startPos = pawn.atHome ? myEntry : pawn.pos;
          if(pawn.atHome){
            // can only move out of home if entry is not blocked and dice allows a legal move
            if(blocked.has(myEntry)) return;
          }
          // Build blocked set but allow capturing opponent on final cell
          const blockedForPath = new Set(blocked);
          // If this pawn is on the path, remove its own current cell from blocked
          if(!pawn.atHome) blockedForPath.delete(startPos);

          // Special rule: goal can't be crossed; only exact landing
          const destinations = Array.from(shortestPaths(startPos, state.dice, blockedForPath));

          // Remove cells that are not in PATH or are homes
          const legal = destinations.filter(k=>PATH.has(k) || k===GOAL);
          if(pawn.atHome && state.dice===0) return;

          // mark pawn as clickable if any legal moves
          const myCell = pawn.atHome ? HOMES[me.color].slots[Math.min(idx,4)] : pawn.pos;
          const pawnEl = cells.get(myCell)?.querySelector('.pawn');
          if(legal.length>0 && pawnEl){
            pawnEl.classList.add('owned','clickable');
            pawnEl.addEventListener('click', ()=>{
              unmarkHints();
              markHints(legal);
              // clicking on a target performs move
              legal.forEach(dest=>{
                cells.get(dest).addEventListener('click', ()=>{
                  performMove(dest);
                }, { once:true });
              });
            }, { once:true });
          }

          function performMove(dest){
            // Transaction to move pawn idx to dest, resolve captures & barricades, advance turn
            runTransaction(gameRef, (st)=>{
              if(!st) return st;
              const cur = st.order[st.turnIndex]; if(cur!==ME) return st;
              const meState = st.players[ME]; if(!meState) return st;
              const p = meState.pawns[idx];

              // recompute validity quickly on server-side state
              const allP2 = allPawnsArray(st.players);
              const occupied2 = new Set(allP2.map(pp=>pp.pos));
              const blocked2 = new Set(st.barricades.concat(Array.from(occupied2)));
              const start2 = p.atHome ? HOMES[meState.color].entry : p.pos;
              if(p.atHome && blocked2.has(start2)) return st;
              if(!p.atHome) blocked2.delete(start2);
              const legal2 = Array.from(shortestPaths(start2, st.dice, blocked2)).filter(k=>PATH.has(k) || k===GOAL);
              if(!legal2.includes(dest)) return st; // invalid (race condition)

              // capture opponent on dest (if any)
              for(const [opName,op] of Object.entries(st.players)){
                if(opName===ME) continue;
                op.pawns.forEach((opP)=>{
                  if(opP.pos===dest && !opP.atHome){
                    opP.pos="home"; opP.atHome=true;
                  }
                });
              }

              // move my pawn
              p.pos = dest; p.atHome = false;

              // win check
              if(dest===st.goal){
                st.winner = ME;
              }

              // barricade interaction: if landing on barricade, we must pick it up and place elsewhere
              const bIndex = st.barricades.indexOf(dest);
              if(bIndex>=0){
                // remove barricade from dest; defer placement by setting a flag
                st.barricades.splice(bIndex,1);
                st._mustPlaceBarricade = true;
                st._placer = ME;
              }else{
                // normal end of turn
                st.dice = 0;
                if(!st.winner){
                  st.turnIndex = (st.turnIndex + 1) % st.order.length;
                }
              }
              return st;
            });
            unmarkHints();
          }
        });
      }

      // If we must place a barricade (after capturing one), let the placer choose a cell
      if(state._mustPlaceBarricade && state._placer===ME){
        // Blocked cells: goal, any home slots, occupied
        const occupied = new Set(allPawnsArray(state.players).map(p=>p.pos));
        const forbidden = new Set([GOAL]);
        Object.values(HOMES).forEach(h=>h.slots.forEach(s=>forbidden.add(s)));
        const choices = [...PATH].filter(k=>!occupied.has(k) && !forbidden.has(k));
        markHints(choices);
        choices.forEach(dest=>{
          cells.get(dest).addEventListener('click', ()=>{
            runTransaction(gameRef, (st)=>{
              if(!st || !st._mustPlaceBarricade || st._placer!==ME) return st;
              if(!PATH.has(dest)) return st;
              const occupied2 = new Set(allPawnsArray(st.players).map(p=>p.pos));
              const forbidden2 = new Set([GOAL]); Object.values(HOMES).forEach(h=>h.slots.forEach(s=>forbidden2.add(s)));
              if(occupied2.has(dest) || forbidden2.has(dest)) return st;
              st.barricades.push(dest);
              st._mustPlaceBarricade = false;
              st._placer = "";
              // end turn after placing
              st.dice = 0;
              if(!st.winner){
                st.turnIndex = (st.turnIndex + 1) % st.order.length;
              }
              return st;
            });
            unmarkHints();
          }, { once:true });
        });
        toast("Place la barricade rÃ©cupÃ©rÃ©e : clique sur une case du chemin (pas sur dÃ©part/arrivÃ©e).");
      }

      if(state.winner){
        toast("ðŸŽ‰ " + state.winner + " a gagnÃ© !");
      }
    }

    // Fill gameId from URL query for convenience
    (function initInputsFromURL(){
      const gid = new URLSearchParams(location.search).get("game");
      if(gid) gameIdInput.value = gid;
    })();
  </script>
</body>
</html>
